---
title: "labvsfield_QMRA"
author: "Camille Zimmer"
date: "2024-03-01"
output: html_document
---

```{r setup, include=FALSE, set.seed(123)}
knitr::opts_chunk$set(echo = TRUE)

#Clear environment
rm(list = ls())

#Load libraries
library(tidyverse)       # For tidy datasets and graphing 
library(fitdistrplus)    # For fitting distributions
library(readxl)          # For reading excel files
library(writexl)         # For writing excel files
library(mc2d)            # For monte carlo draws
library(truncnorm)       # To draw from a truncated normal distribution
library(patchwork)       # For graphing, to stitch multiple graphs together
library(RColorBrewer)    # For making nicely coloured graphs
library(gt)              # For making summary tables

# Define number of Monte Carlo observations we want per draw (currently 100 for the first chunks, will be redefined further down)
nMC = 100

```


```{r load field LRV data, include=FALSE}

## Load in spreadsheet of LRVs from fieldwork, with corresponding manufacturer claims if available
# This df is used below in the chunk "cycle through all the manuf-field LRV pairs"
rawLRVdata = read_excel("inputdata/LRVs_forQMRA.xlsx", skip = 5)

## Data wrangling
# Select relevant columns and drop rows with no manufacturer claim
rawLRVdata = rawLRVdata %>%
    dplyr::select(row_num, 
                  treatment_type,
                  treatment_name,
                  organism,
                  LRV_field,
                  LRV_manuf
                  ) %>%
    drop_na()

```


# Part I: Define MC draw functions for QMRA 
## Draw for pathogen concentration in the raw water, for each "DW event"
### Draw for campylobacter
```{r draw_campy}

# See "fitenvdata_forQMRAinputs" file for code used to find fit parameters

# Function inputs:
#  nMC: the number of monte carlo draws to carry out
#  plotsdisp: whether to display a summary plot of one of the refill draws
#  Distribution parameters (prevalence and concentration) are initialized within the function

# Function outputs:
#  rawcampyconc: a 21 x nMC dataframe where each column is nMC draws for campylobacter concentration for a given water refill
#  Note: rawcampyconc has units of CFU/L
draw_campy = function(nMC, plotsdisp) {
    
        # See "fitenvdata_forQMRAinputs" code for code and data used to find fit parameters
        # We'll use meanlog = 1.94, sdlog = 2.22 (Units in CFU/100 mL) --> per Pintar et al (2017)
        
        list = list() #create an empty list
        
        # First, draw nMC times for the campy concentration
                for (i in 1:21) {
                    vec = numeric(nMC) #preallocate a numeric vector
                    vec = rlnorm(nMC, meanlog = 1.94, sdlog = 2.22) # Units in CFU/100 mL
                    list[[i]]  = vec
                }
        
        # Wrangle data
        rawcampyconc = do.call("rbind",list)
        rawcampyconc = as.data.frame(rawcampyconc)
        rawcampyconc = t(sapply(rawcampyconc, as.numeric))
        rawcampyconc = as.data.frame(rawcampyconc)


        # Replace some % of values with non-detect to account for prevalence
        # Prevalence taken from Murphy et al (2016), which is a PERT dist with min = 0, mode = 0.25, max = 0.587 (shape factor not specified)
        # https://stackoverflow.com/questions/70401107/r-randomly-changing-values-in-a-dataframe
        # https://stackoverflow.com/questions/72313629/r-randomly-replace-values-with-na
        # In cases where values are replaced with zero, instead replace them with a value from a PDF to reflect the LDL of Campy sampling
        # For campy, the LDL is 1 CFU/100 mL, so 10 CFU in 1 L.  
        # Make function to replace some % of values with a non-detect
            FUNcampy = function(x) {
                censvaluecampy = runif(1, min = 0, max = 1) # Units in CFU/100 mL, define the non-detect value
                probcampy = rpert(1, min = 0, mode = 0.25, max = 0.578) # probability of a non-detect
                sample(c(x, censvaluecampy), 1, prob=c(probcampy,(1 - probcampy))) # Replace values in the rawcampyconc df with non-detects
                }
        rawcampyconc <- as.data.frame(apply(rawcampyconc, 1:2, FUNcampy)) # Use FUNcampy function to replace values; units in CFU/100 mL
        rawcampyconc = rawcampyconc * 10 # Get in units of CFU/1 L

        #Visualise one of the draws (set to lucky #13 for now, could set to be rand(1,21) later)
        if (plotsdisp == TRUE) {
            plot(density(rawcampyconc$V13))
        }

return(rawcampyconc)

}

# Check that it works
rawcampyconc = draw_campy(nMC = nMC, plotsdisp = T) # Units of CFU/L

```

### Draw for Giardia
```{r draw_giardia}

# See "fitenvdata_forQMRAinputs" file for code used to find fit parameters
# We'll use meanlog = 0.6408606, sdlog = 0.7579550; units of oocysts/100 L --> per Lucas (1998)
# 14% prevalence (point value)

# Function inputs:
#  nMC: the number of monte carlo draws to carry out
#  plotsdisp: whether to display a summary plot of one of the refill draws
#  Distribution parameters (prevalence and concentration) are initialized within the function

# Function outputs:
#  rawgiardiaconc: a 21 x nMC dataframe where each column is nMC draws for giardia concentration for a given water refill
#  Note: rawgiardiaconc has units of oocysts/L


draw_giardia = function(nMC, plotsdisp) {
    # Step 1: create data frame with cocnentrations of Giardia
    list = list() #create an empty list
    
    # Populate data frame
    # See "fitenvdata_forQMRAinputs" code for code and data used to find fit parameters
    # We'll use meanlog = 0.6408606, sdlog = 0.7579550; units of oocysts/100 L --> per Lucas (1998)
    # 14% prevalence (point value)
        for (i in 1:21) {
            vec = numeric(nMC) #preallocate a numeric vector
            vec = rlnorm(nMC, meanlog = 0.6408606, sdlog = 0.7579550) # Units in oocysts/100 L
            list[[i]]  = vec
        }
    # data wrangling
    rawgiardiaconc = do.call("rbind",list)
    rawgiardiaconc = as.data.frame(rawgiardiaconc)
    rawgiardiaconc = t(sapply(rawgiardiaconc, as.numeric))
    rawgiardiaconc = as.data.frame(rawgiardiaconc)

    # Step 2: randomly replace 14.2857142857143% of the samples with 0 (see summary spreadsheet with data from Lucas et al)
    # https://stackoverflow.com/questions/70401107/r-randomly-changing-values-in-a-dataframe
    # https://stackoverflow.com/questions/72313629/r-randomly-replace-values-with-na
    # In cases where values are replaced with zero, instead replace them with a value from a PDF to reflect the LDL of Campy sampling
    # For giardia, the LDL is 1 oocyst/100 L, so 0.01 CFU in 1 L.  
    # Make function to replace some % of values with a non-detect
    FUNgiardia = function(x) {
        censvaluegiardia = runif(1, min = 0, max = 1) # Define non-detect value; units in oocysts/100 L
        probgiardia = 0.142857142857143 # Define giardia prevalence
        sample(c(x, censvaluegiardia), 1, prob=c(probgiardia,(1 - probgiardia))) # Randomly replace 14% of values with a non-detct
        }
    rawgiardiaconc <- as.data.frame(apply(rawgiardiaconc, 1:2, FUNgiardia ))  # Units in oocysts/100 L
    rawgiardiaconc = rawgiardiaconc/100  # Get in units of oocysts/1 L


    #Visualise one of the refills (set to lucky #13 for now, could set to be rand(1,21) later)
    if (plotsdisp == TRUE) {
    plot(density(rawgiardiaconc$V13))
    }
    
    # Output value
    return(rawgiardiaconc)
}

# Check that it works
rawgiardiaconc = draw_giardia(nMC = nMC, plotsdisp = T) # Units of oocysts/1 L

```

## Populate dataframes with an LRV
```{r make LRV dataframe}

## Function to make a matrix out of a given LRV
# Simply takes an input LRV and makes an nxn dataframe populated with it
# Used to make an 21 x nMC dataframe of LRVs for calculations

# Inputs
#   LRV: point value to be replicated into dataframe
#   nrows: how many rows in the df, should be nMC
#   ncols: how many columns in the df, should be 21

# Outputs
#   LRVs: an ncols x nrows dataframe populated with LRV in every cell

FUNmakeLRVmx = function(LRV, nrows, ncols){
    
    LRVs = rep(LRV, times = nrows)
    LRVs = data.frame(LRVs)
    LRVs = cbind(LRVs, rep(LRVs[1], (ncols-1)))
    colnames(LRVs) = 1:ncol(LRVs)
    return(LRVs)
    
}



#Check using the first entry of the LRVs_forsummary input data table
LRVs_Ecoli = FUNmakeLRVmx(LRV = 4.19, nrows = nMC, ncols = 21)
LRVs_yeast = FUNmakeLRVmx(LRV = 3.73, nrows = nMC, ncols = 21)

```

## Draw for drinking water consumption in each "DW event" (Refill)
```{r draw_DW_consumption}

# Based on curve fitting of survey data, we can assume that reported DW consumed in a day follows a truncated normal distribution
# mean = 0.816667 L, SD = 0.3496667 L, lower limit = 0.25 L **This is per water refill, NOT per day** (21 refills in a 7-day trip)
# see "fitenvdata_forQMRA" R code for how those parameters were generated


## Define function to make MC draws for water consumed per refill
# Inputs
#   nMC: the number of monte carlo draws to carry out
#   plotsdisp: whether to display a summary plot of one of the refill draws
#   Distribution parameters (volume of water consumed per refill) are initialized within the function
# Outputs
#   DWvol: a 21 x nMC dataframe populated for draws of the volume of water consumed per refill 
#          Units in L per refill (21 refills in a 7-day trip)


drawDW = function(nMC, plotsdisp){

    list = list() #create an empty list
    
    # Make nMC draws for volume of water consumed per refill
    for (i in 1:21) {
        vec = numeric(nMC) #preallocate a numeric vector
        mean = 2.446786*(1/3)
        sd = 1.049*(1/3)
        vec = rtruncnorm(n = nMC, a = 0.25, b = Inf, mean = mean, sd = sd) # Trunate at 0.25 L, or half of the mean
        list[[i]]  = vec
    }
    
    # Wrangle data
    DWvol = do.call("rbind",list)
    DWvol = as.data.frame(DWvol)
    DWvol = t(sapply(DWvol, as.numeric))
    DWvol = as.data.frame(DWvol)
    
    #Visualise one of the draws (set to lucky #13 for now, could set to be rand(1,21) later)
    if (plotsdisp == TRUE) {
    plot(density(DWvol$V13))
    }
    
    # DWvol units in L per refill (21 refills per 7-day trip)
    return(DWvol)

}

# Check that it works
DWvol = drawDW(nMC = nMC, plotsdisp = T)

```

## Calculate pathogen exposure per DW event and over the 7-day backpacking trip
```{r calc_exposure}

### Step 1: Calculate exposure in each of the 21 DW refills
## Reminder: conc of campy and giardia should be #/L before feeding to this function
# I.e., raworgconc should be in units of organisms per liter

# Define function to calculate the exposure to a given pathogen during each of the 21 refills
# Inputs
#   LRVs: a 21 x nMC dataframe populated with the point-value LRV for the water treatment device (see chunk "Populate dataframes with LRV")
#   raworgconc: a 21 x nMC dataframe populated with the MC draws for pathogen concentration in water (units of #/L)
#               see the "Draw for campylobacter" and "draw for giardia" chunks
#   DWvol: a 21 x nMC dataframe populated with the nMC draws for water volume consumed per refill (units of L per refill)
# Outputs
#   exposure: a 21 x nMC dataframe with each cell containing the number of pathogens consumed per refill


calc_exposure = function(LRVs, raworgconc, DWvol, plotsdisp) {
    
    # Step 1: Calculate what the pathogen concentration will be in the drinking water
    survival = 10^(-1*LRVs) # Units as a % of the number in the raw water [unitless]
    DW_orgconc = raworgconc * survival # Units of #organisms/1 L
    
    # Step 2: Exposure per draw of water
    # exposure = volume of water consumed in the draw [L] * pathogen concentration in that water [#/L]
    exposure = DWvol * DW_orgconc # Units of #organisms drunk in the refill event
    
    if (plotsdisp == TRUE) {
    plot(density(exposure$V13))
    }
    
    # exposure is the number of pathogens consumed per refill (units of #/refill)
    return(exposure)
    
}

# Check it works
exposure_campy = calc_exposure(LRVs = LRVs_Ecoli, raworgconc = rawcampyconc, DWvol = DWvol, plotsdisp = T)  # Units of CFU campylobacter drunk in the refill event
exposure_giardia = calc_exposure(LRVs = LRVs_yeast, raworgconc = rawgiardiaconc, DWvol = DWvol, plotsdisp = T)  # Units of Giardia oocysts drunk in the refill event


## Step 2: Sum across all 21 DW refills --> this will be the total pathogens consumed in a 7-day backpacking trip
# Note: This is the first of three model endpoints

# Define a function to calculate the total number of pathogens consumed in a 7-day backpacking trip
# Inputs
#   exposure: the output from the function calc_exposure, 21 x nMC matrix with each cell as the number of pathogens consumed per refills
# Outputs
#   exposure_trip: the total number of pathogens consumed in a 7-day backpacking trip (units of # of pathogens)

calc_tripexposure = function(exposure, plotsdisp) {
    
    # Sum all the 21 exposures across the rows
    exposure_trip = exposure %>%
        mutate(sum = rowSums(.[1:21]))
    exposure_trip = exposure_trip$sum
    
    #Display
    if (plotsdisp == TRUE) {
        plot(density(exposure_trip))  
    }
    
    # Output is exposure_trip, total number of pathogens consumed per trip
    return(exposure_trip)
}

# Check it works
exposure_campy_trip = calc_tripexposure(exposure = exposure_campy, plotsdisp = T)  # Units of total CFU campylobacter drunk on a 7-day backpacking trip
exposure_giardia_trip = calc_tripexposure(exposure = exposure_giardia, plotsdisp = T)  # Units of Giardia oocysts drunk on a 7-day backpacking trip

```


## Calculate P(inf) per refill
```{r calc_Pinf_refill}

## Campylobacter ## 

# From Medema (1996) we have a MLE Beta-Poisson model with alpha = 0.145 and N50 = 890
# This model is not used by Murphy (2016) but is used by Bivins (2019) -- although he also uses the Teunis model

# NOTE: maybe put in the Teunis model and weight them 50/50? For later

# Define function to calculate the probability of infection with Campylobacter per refill
# Inputs
#   exposure_campy: a 21 x nMC dataframe with each cell containing the number of campylobacter consumed per refill
#                   see chunk "calc_exposure" for details
# Outputs
#   Pinf_campy: a 21 x nMC with each cell containing the Pinf with campylobacter per refill

Pinf_c = function(exposure_campy, plotsdisp) {
    
    # Define Pinf parameters
    alpha = 0.145
    N50 = 890
    beta = 7.59
    
    # Calculate Pinf_campy
    Pinf_campy = 1 - (1+(exposure_campy*((2^(1/alpha) - 1)/N50)))^(-1*alpha)
    
    # Plot lucky #13
        if (plotsdisp == TRUE) {
            plot(density(Pinf_campy$V13))
        }
    # Return output
    return(Pinf_campy)
}

# Check it works
Pinf_campy = Pinf_c(exposure_campy = exposure_campy, plotsdisp = T)

## Giardia ##

# Rose et al (1991) is used by Murphy (2016) and recommended by WHO (2016)
# Exponential calculation with r = 0.0199

# Define function to calculate the probability of infection with Giardia per refill
# Inputs
#   exposure_giardia: a 21 x nMC dataframe with each cell containing the number of giardia consumed per refill
#                   see chunk "calc_exposure" for details
# Outputs
#   Pinf_giardia: a 21 x nMC with each cell containing the Pinf with giardia per refill  

Pinf_g = function(exposure_giardia, plotsdisp) {
    
    # Define Pinf parameters
    r = 0.0199
    
    # Calculate Pinf
    Pinf_giardia = 1-exp(-1*r*exposure_giardia)
    
    # Plot lucky #13
        if (plotsdisp == TRUE) {
            plot(density(Pinf_giardia$V13))
        }
    # Return output
    return(Pinf_giardia)
}

# Check it works
Pinf_giardia = Pinf_g(exposure_giardia = exposure_giardia, plotsdisp = T)
```


## Calculate total P(inf) for the 7-day trip
```{r calc_Pinf_trip}

## Calculate the overall probability of infection for the 7-day backpacking trip 
# Note: This is the second of three model endpoints
# Formula -->  Pinf_trip = 1 - [(1-Pinf, refill 1)*(1-Pinf, refill 2)...*(1-Pinf, refill 21)]

# Define function to do calculation
# Inputs
#   Pinf: a 21 x nMC with each cell containing the Pinf with the pathogen per refill
# Outputs
#   Pinf_trip: a 1 x nMC dataframe with the overall probability of infection for the 7-day backpacking trip (unitless)

Pinf_trip = function(Pinf, plotsdisp) {
    
    # Do calculations
    Pinf_oneminus = 1-Pinf
    Pinf_trip = Pinf_oneminus %>%
        mutate(prod = Reduce(`*`, .))
    Pinf_trip = Pinf_trip$prod
    Pinf_trip = 1-Pinf_trip
    
    # Plot
    if (plotsdisp == TRUE) {
        plot(density(Pinf_trip))  
    }
    
    # Return output
    return(Pinf_trip)
}

# Check it works
Pinf_campy_trip = Pinf_trip(Pinf = Pinf_campy, plotsdisp = T)  # Probability of infection with Campylobacter for a 7-day backpacking trip
Pinf_giardia_trip = Pinf_trip(Pinf = Pinf_giardia, plotsdisp = T)  # Probability of infection with Campylobacter for a 7-day backpacking trip

```


```{r calc_Pill_given_Pinf}

# Define function to populate a dataframe with the probability of illness given infection, Pillinf
# Pillinf is a decimal (i.e., % chance), from 0.1 to 0.6 for Campy and 0.2 to 0.7 for Giardia

# Pill = Pinf*Pillinf
# Use Pillinf from Murphy (2016): a uniform distribution (originally from USEPA, 2010)
# Campy has min = 0.1, max = 0.6
# Giardia has min = 0.2, max = 0.7

# Inputs
#   nMC: the number of monte carlo draws to carry out
#   min: the mimimum of the uniform distribution of Pillinf
#   max: the maximum of the uniform distribution of Pillinf
# Outputs
#   Pillinf: the probability of having a symptomatic illness given Pinf
#   This will be used in the DALY calculation



Pill_given_Pinf = function(nMC, min, max, plotsdisp) {
    Pillinf = runif(nMC, min = min, max = max) # Probability of illness given infection
    # Display
    if (plotsdisp == TRUE) {
        plot(density(Pillinf))  
    }
    return(Pillinf)
}

## Try the function out
# Campy
Pill_given_Pinf_campy = Pill_given_Pinf(nMC = nMC, min = 0.1, max = 0.6 , plotsdisp = T)
Pill_trip_campy = Pinf_campy_trip * Pill_given_Pinf_campy
# Giardia
Pill_given_Pinf_giardia = Pill_given_Pinf(nMC = nMC, min = 0.2, max = 0.7 , plotsdisp = T)
Pill_trip_giardia = Pinf_giardia_trip * Pill_given_Pinf_giardia

```


## Calculate DALYs per trip
```{r calc_DALYs}

# Define function to calculate the total DALYs per 7-day backpacking trip

# DALYs per illness = Pill * S * DW * number of people or life years (per Bivins 2019)
# Where:
# Pill was calculated in the last chunk


# Inputs
#   Pill_trip: the overall probability of having a symptomatic illness from the 7-day backpacking trip
#   S: the susceptible fraction; for both campy and giardia, S = 100%
#   DW: DALY weighting, the expected DALY weight per illness/case
#   n_campingtrips: how many camping trips to calculate for. For our purposes here, it will always be 1 but if we were calculating DALYs on a                      per summer basis it could be the number of people hiking the JDF per summer
# Outputs
#   DALYs: Total DALYs per 7-day backpacking trip

calcDALYs = function(Pill_trip, S, DW, n_campingtrips, plotsdisp) {
    
    # Calculations
    DALYs = Pill_trip * S * DW * n_campingtrips
    
    # Display
    if (plotsdisp == TRUE) {
        plot(density(DALYs))  
    }
    # Output
    return(DALYs)
}


## Try the function out
# Initialize values
# DW_campy = 4.6 per 1000 cases --> From WHO (2016), used in Bivins (2019)
DW_campy = 4.6/1000 # Units of DALY per illness case
# DW_giardia = 1.7 per 1000 cases --> From Health Canada (2012)
DW_giardia = 1.7/1000   # Units of DALY per illness case
# 100% susceptibility
S = 1
# If n_campingtrips = 1, then the DALYs are in units of DALY per person per camping trip
n_campingtrips = 1

# Use functions
DALY_campy = calcDALYs(Pill_trip = Pill_trip_campy, S = S, DW = DW_campy, n_campingtrips = n_campingtrips, plotsdisp = T)  # Units of YLL per year of backpackers hiking
DALY_giardia = calcDALYs(Pill_trip = Pill_trip_giardia, S = S, DW = DW_giardia, n_campingtrips = n_campingtrips, plotsdisp = T)  # Units of YLL per year of backpackers hiking

```


## Calculate endpoints given MC drawn inputs
```{r calc_endpoints}


# Define function to calculate the QMRA endpoints (dose, Pinf, DALYs)

## Inputs:
# LRV and microbe (campy or giardia)
# MC draws: WQ conc = raw water pathogen concentration
#           DW vol = water vol drunk per refill
#           Pillgiven inf = probability of illnes given infection with either campy or giardia
#           all 21 x nMC dataframes with MC draws
# Other point values: S = susceptability fraction (100% for campy and giardia)
#                     n_campingtrips = number of camping trips (1 for our study)
#                     DALY_weight = DALY weighting per illness
#                     nMC = number of monte carlo draws    

## Outputs:
# endpoints dataframe, which is 5 x nMC, containing:
# endpoint_exposure = endpoint #1, total pathogen ingestion over the backpacking trip 
# endpoint_Pinf = endpoint #2, probability of infection from the 7-day backpacking trip  
# endpoint_DALY = endpoint #3, DALYs from the 7-day trip
# process_rawWQtrip = for sensitivity analysis, total pathogens in raw water over the 7-day backpacking trip
# process_DWvoltrip = for sensitivity analysis, total water volume drunk over the 7-day trip


calc_endpoints = function(S, n_campingtrips, DALY_weight, nMC,  # Point values
                          DW_conc, DWvol, Pillinf,      # 21 x nMC dataframes populated via MC draws
                          LRV, microbe) {                       # Point values for microbe
    
    # Populate LRV matrix
    LRVmx = FUNmakeLRVmx(LRV = LRV, nrows = nMC, ncols = 21)
    
    
    # Calculate dose (endpoint #1)
    #   a: Calculate dose per refill
    exposure = calc_exposure(LRVs = LRVmx, raworgconc = DW_conc, DWvol = DWvol, plotsdisp = F) # Units of organisms/L
    #   b: Calculate total dose over the 7-day trip
    tripexposure = calc_tripexposure(exposure = exposure, plotsdisp = F)  # Units of total organisms drunk per trip
    
    
    # Calculate Pinf (endpoint #2)
    #   a: Use dose-response calculation for each refill
    if(microbe == "Ecoli"){  
        # Campylobacter dose-response
        Pinf = Pinf_c(exposure = exposure, plotsdisp = F)
        
    } else {
        # Giardia dose-response
        Pinf = Pinf_g(exposure = exposure, plotsdisp = F)
    }
    #   b: Calculate the overall Pinf for the trip
    Pinf_trip = Pinf_trip(Pinf = Pinf, plotsdisp = F)
    
    
    # Calculate DALYs per trip (endpoint #3)
    #    a: Calculate the Pill, using Pillinf
    Pill_trip = Pinf_trip * Pillinf
    #    b: Calculate DALYs (units of YLL)
    DALY_trip = calcDALYs(Pill_trip = Pill_trip, 
                          S = S, 
                          DW = DALY_weight, 
                          n_campingtrips = n_campingtrips, 
                          plotsdisp = F)
    
    
    ## Calculation for later correlations analysis
    # Total microbes in raw water over the trip
    DW_conc = DW_conc %>%
        mutate(sum = rowSums(.[1:21]))
    DW_raw_trip = DW_conc$sum
    # Total DW drunk over the trip
    DWvol = DWvol %>%
        mutate(sum = rowSums(.[1:21]))
    DWvol_trip = DWvol$sum
    
    
    # Wrangle data
    endpoints = tibble(tripexposure, Pinf_trip, DALY_trip, # endpoints
                       DW_raw_trip, DWvol_trip) %>%        # For correlations
        rename(
            endpoint_exposure = tripexposure, 
            endpoint_Pinf = Pinf_trip, 
            endpoint_DALY = DALY_trip,
            process_rawWQtrip = DW_raw_trip,
            process_DWvoltrip = DWvol_trip
        )

    
    # Return output
    return(endpoints)
    
}

# Try the function
try_endpoints_campy = calc_endpoints(S = S, n_campingtrips = n_campingtrips, DALY_weight = DALY_campy, nMC = nMC,
                                 DW_conc = rawcampyconc, DWvol = DWvol, Pillinf = Pill_given_Pinf_campy,
                                 LRV = 4, microbe = "Ecoli")

```



# Part II:  Put all the functions together to do the QMRA
## Do one QMRA for a manuf-field LRV pair
```{r do one QMRA for one lab vs field pair}

#### Define function to compare lab vs field QMRA for a given lab-field pair of data for a given device
# This function will be used in the next chunk in a for loop

# Inputs:
#   nMC: the number of monte carlo draws to carry out
#   LRV_manuf: point-value LRV claimed by manufacturers
#   LRV_field: point-value LRV obtained in 2021 field study
#   microbe: either "campy" or "giardia"

# Outputs
# the oneQMRA dataframe, which is 13 x (2 x nMC), containing:
# info_surveynum = which survey the data pair comes from (should be one campy and one giardia per survey)
# info_pairnum = which lab-field data pair the data belong to
# info_treatmenttype = "chemical", "filter" or "UV"
# info_treatmentname = which treatment device was used
# info_organism = "campy" or "giardia'
# info_setting = "manuf" or "field"
# input_LRV = the point-value LRV 
# process_DWvoltrip = explained in above chunk
# process_rawWQtrip = explained in above chunk
# process_Pillinf = probability of illness given infection
# endpoint_exposure = explained in above chunk
# endpoint_Pinf = explained in above chunk
# endpoint_DALY = explained in above chunks


doQMRA_labvfield = function(nMC, LRV_manuf, LRV_field, microbe) {
    
    
    ## Do MC draws: WQ_conc, DW_vol, Pillinf
    # DW_conc, Pillinf, depend on the choice of microbe
    # Draw for DWvol
    DWvol = drawDW(nMC = nMC, plotsdisp = F)
    
    # Draw for WQ_conc and Pillinf
    if(microbe == "Ecoli"){  
        # Campylobacter 
        WQ_conc = draw_campy(nMC = nMC, plotsdisp = F)
        Pillinf = Pill_given_Pinf(nMC = nMC, min = 0.1, max = 0.6, plotsdisp = F) # Murphy (2016), originally from USEPA (2010)
        DALYweight = 4.6/1000 # Units of DALY per illness case --> From WHO (2016), used in Bivins (2019)
        
    } else {
        # Giardia dose-response
        WQ_conc = draw_giardia(nMC = nMC, plotsdisp = F)
        Pillinf = Pill_given_Pinf(nMC = nMC, min = 0.2, max = 0.7, plotsdisp = F) # Murphy (2016), originally from USEPA (2010)
        DALYweight = 1.7/1000   # Units of DALY per illness case --> From Health Canada (2012)
    }
    
    
    ## Calculate endpoints, using LRV_manuf and LRV_field
    # Using LRV_field
    endpoints_field = calc_endpoints(nMC = nMC, 
                                     S = 1, 
                                     n_campingtrips = 1, 
                                     DALY_weight = DALYweight, 
                                     DWvol = DWvol,
                                     DW_conc = WQ_conc, 
                                     Pillinf = Pillinf,
                                     LRV = LRV_field, 
                                     microbe = microbe)
    # USing LRV_manuf
    endpoints_manuf = calc_endpoints(nMC = nMC, 
                                     S = 1, 
                                     n_campingtrips = 1, 
                                     DALY_weight = DALYweight, 
                                     DWvol = DWvol,
                                     DW_conc = WQ_conc, 
                                     Pillinf = Pillinf,
                                     LRV = LRV_manuf, 
                                     microbe = microbe)
    

    
    ## Wrangle data
    
    # add setting names ("field" or "manuf") to both endpoints tables
    # Also Pillinf so that we can do correlations analysis later
    # And the input LRV (field or manuf)
    endpoints_field = endpoints_field %>%
        mutate(info_setting = "field", .before = endpoint_exposure) %>%
        mutate(process_Pillinf = Pillinf) %>%
        mutate(input_LRV = LRV_field, .after = info_setting)
    endpoints_manuf = endpoints_manuf %>%
        mutate(info_setting = "manuf", .before = endpoint_exposure) %>%
        mutate(process_Pillinf = Pillinf) %>%
        mutate(input_LRV = LRV_manuf, .after = info_setting)
    
    # Use rbind to make one big dataframe
    endpoints = rbind(endpoints_field, endpoints_manuf)
    
    # Output
    oneQMRA = endpoints
    return(oneQMRA)
    
}

# Try one QMRA
tryoneQMRA = doQMRA_labvfield(nMC = nMC,
                              LRV_manuf = 4, LRV_field = 2,
                              microbe = "Ecoli")

```


## Do a for loop for QMRA for all manuf-field LRV pairs
```{r cycle through all the manuf-field LRV pairs - this is the overall QMRA}


# Initialize
nMC = 10000
allQMRA = tibble()

# Do for loop
for(i in 1:nrow(rawLRVdata)) {
    
    # Check
    print(i)
    
    # Initialize row i
    row <- rawLRVdata[i,]
    
    # Call function to do QMRA
    oneQMRA = doQMRA_labvfield(nMC = nMC,
                               LRV_manuf = row$LRV_manuf, 
                               LRV_field = row$LRV_field,
                               microbe = row$organism
                              )
    
    # Wrangle data
    oneQMRA = oneQMRA %>%
        mutate(info_surveynum = row$row_num) %>%  # Indicates which survey the data belong to, so that yeast/ecoli could be paired
        mutate(info_pairnum = i) %>%
        mutate(info_treatmenttype = row$treatment_type) %>%
        mutate(info_treatmentname = row$treatment_name) %>%
        mutate(info_organism = row$organism)
        
    
    # Output
    allQMRA = rbind(allQMRA, oneQMRA)
}

# Reorganize column order
allQMRA = allQMRA %>%
    dplyr::select(info_surveynum,
                  info_pairnum,
                  info_treatmenttype,
                  info_treatmentname,
                  info_organism,
                  info_setting,
                  
                  input_LRV,
                  
                  process_DWvoltrip,
                  process_rawWQtrip,
                  process_Pillinf,
                  
                  endpoint_exposure,
                  endpoint_Pinf,
                  endpoint_DALY
                  )


# pivot longer (needed for making figures below, and correlations analysis)
allQMRA_long = allQMRA %>%
    pivot_longer(
            cols = starts_with("endpoint"),
            names_to = "endpoint_name",
            values_to = "endpoint_value",
            names_prefix = "endpoint_"
    ) 


```


# Figures for publication
## Data wrangling
```{r wrangle data for figures}

### Wrangle data more, to figure out the difference in lab vs field endpoints
allQMRA_graph = allQMRA_long %>%
    pivot_wider(                    # Pivot wider so that manuf - field can be calculated
        names_from = info_setting,
        values_from = c(endpoint_value, input_LRV)
    ) %>%
    dplyr::select(                  # Select the relevant columns
                  info_surveynum,
                  info_pairnum,
                  info_treatmenttype,
                  info_treatmentname,
                  info_organism,

                  input_LRV_field,
                  input_LRV_manuf,
                  
                  endpoint_name,
                  endpoint_value_field,
                  endpoint_value_manuf,
                  ) 
    
# Subtract endpoints to find the difference
# Take endpoint_field - endpoint_manuf
# and LRV_field - LRV_manuf
# So that if LRV_manuf > LRV_field, then the difference in health risk would be positive
# and difference in LRV would be negative
allQMRA_graph = allQMRA_graph %>%
    mutate(endpoint_value_subtract = endpoint_value_field - endpoint_value_manuf) %>%
    mutate(input_LRV_subtract = input_LRV_field - input_LRV_manuf, .after = input_LRV_manuf)


### Calculate overall means for graphing
# Get means
allQMRA_graphmeans = allQMRA_graph %>%
    group_by(info_organism, info_treatmenttype, endpoint_name) %>%      # Tell R to group means by these variables
    summarise(
        n = n(), 
        endpoint_value_subtract_mean = mean(endpoint_value_subtract)    # Get mean values
    ) %>%
    mutate(endpoint_value_subtract_mean_yval = 1)         # Initialize the column for yvalues corresponding to that mean


# Get corresponding y-values for those means
# Do a for loop
for(i in 1:nrow(allQMRA_graphmeans)) {
    # Check
    print(i)

    # Initialize row i
    row <- allQMRA_graphmeans[i,]
    
    # Get corresponding y-value
    yval = ecdf(
        filter(allQMRA_graph,
               info_organism == row$info_organism, 
               info_treatmenttype == row$info_treatmenttype, 
               endpoint_name == row$endpoint_name)$endpoint_value_subtract
    )(row$endpoint_value_subtract_mean)

    # Put into allQMRA_graphmeans dataframe under yvalues
    allQMRA_graphmeans[i, "endpoint_value_subtract_mean_yval"] = yval
}


### Graph setup 
# Establish colour palette, from Rcolourbrewer palette "RdYlBu"
brew_11 = c("#A50026",
            "#D73027",
            "#F46D43",
            "#FDAE61",
            "#FEE090",
            "#FFFFBF",
            "#E0F3F8",
            "#ABD9E9",
            "#74ADD1",
            "#4575B4",
            "#313695")
brew_3 = c("#A50026", "#FC8D59", "#4575B4")
fill_3 = c("#DB99A8","#FED1BD","#B5C8E1")

# Make facet label names
treatment_type_labs = c("a) Chemical disinfection", "b) Filtration", "c) UV disinfection")
names(treatment_type_labs) = c("chemical", "filter", "UV")


```


## Campylobacter figure
```{r campy figure, fig.width= 8, fig.height=11}


## Draw graph for exposure
plot_subtractendp_exposure_c = ggplot() +
                            
                            # Plot ecdf lines for each lab-field data pair
                            stat_ecdf(data = filter(allQMRA_graph, info_organism == "Ecoli"  & endpoint_name == "exposure"), 
                                    aes(endpoint_value_subtract, 
                                        colour = info_treatmenttype, 
                                        group = info_pairnum), 
                                    geom = "step", linewidth = 0.15, alpha = 0.55) +
    
                            # Plot ecdf line for all data together
                            stat_ecdf(data = filter(allQMRA_graph, info_organism == "Ecoli"  & endpoint_name == "exposure"), 
                                    aes(endpoint_value_subtract, colour = info_treatmenttype),
                                    geom = "step", linewidth = 0.85, alpha = 1)+

                            # Create 3 panels, one for each treatment type (filter/chemical/UV)
                            facet_wrap( ~ info_treatmenttype, ncol = 1,
                                    labeller = labeller(info_treatmenttype = treatment_type_labs)) +
    
                            # Define scales 
                            scale_x_continuous(trans='pseudo_log',
                                       limits = c(-10, 10000),
                                       breaks = c(-10, -1, 0, 1, 10, 100, 1000, 10000),
                                       minor_breaks = c(-5, -0.5, 0.5, 5, 50, 500, 5000),
                                       labels = c("-10", "-1", "0",
                                                  "+1", "+10", "+100", "+1000", "+10000"))+
                            scale_y_continuous(breaks = c(0.1, 0.5, 0.9), limits = c(0, NA)) +
    
                            # Define axis labels
                            xlab(paste("Difference in dose", "", "", sep = "")) +
                            ylab("") +
    
                            # Draw dashed lines at the 10% and 90% percentiles
                            geom_hline(yintercept = 0.1, linetype = "dashed", colour = "black", size = 0.5, alpha = 0.75) +
                            geom_hline(yintercept = 0.9, linetype = "dashed", colour = "black", size = 0.5, alpha = 0.75) +
    
                            # Draw diamond shapes for mean values
                            geom_point(data = filter(allQMRA_graphmeans, info_organism == "Ecoli"  & endpoint_name == "exposure"),
                                       aes(x = endpoint_value_subtract_mean, 
                                           y = endpoint_value_subtract_mean_yval, 
                                           colour = info_treatmenttype, 
                                           fill = info_treatmenttype),
                                       shape = 23, size = 2.5, stroke = 1.5
                                       ) +
    
                            # Define aesthetic values such as colour
                            theme_bw() +
                            scale_color_manual(values = brew_3) +
                            scale_fill_manual(values = fill_3) +
                            theme(legend.position = "none",
                                  text = element_text(size = 12), 
                                  axis.text.x = element_text(angle = 50, vjust = 1, hjust = 1),
                                  axis.title.x = element_text(size=12),
                                  panel.grid.minor = element_blank(), 
                                  strip.background = element_rect(fill = "white", color = NA),
                                  strip.text.x = element_text(hjust = 0, vjust = 1, size = 12))
plot(plot_subtractendp_exposure_c)



## Draw graph for Pinf
plot_subtractendp_Pinf_c = ggplot() +
                            
                            # Plot ecdf lines for each lab-field data pair
                            stat_ecdf(data = filter(allQMRA_graph, info_organism == "Ecoli"  & endpoint_name == "Pinf"), 
                                    aes(endpoint_value_subtract, 
                                        colour = info_treatmenttype, 
                                        group = info_pairnum), 
                                    geom = "step", linewidth = 0.15, alpha = 0.55) +
    
                            # Plot ecdf line for all data together
                            stat_ecdf(data = filter(allQMRA_graph, info_organism == "Ecoli"  & endpoint_name == "Pinf"), 
                                    aes(endpoint_value_subtract, colour = info_treatmenttype),
                                    geom = "step", linewidth = 0.85, alpha = 1)+

                            # Create 3 panels, one for each treatment type (filter/chemical/UV)
                            facet_wrap( ~ info_treatmenttype, ncol = 1,
                                    labeller = labeller(info_treatmenttype = treatment_type_labs)) +
    
                            # Define scales 
                            scale_x_continuous(trans='pseudo_log',
                                               breaks = seq(from = -0.5, to = 1, by = 0.5),
                                               limits = c(-0.5, 1)) +
                            scale_y_continuous(breaks = c(0.1, 0.5, 0.9), limits = c(0, NA)) +
    
                            # Define axis labels
                            xlab(paste("Difference in", "probability of infection", sep = "\n")) +
                            ylab("") +
    
                            # Draw dashed lines at the 10% and 90% percentiles
                            geom_hline(yintercept = 0.1, linetype = "dashed", colour = "black", size = 0.5, alpha = 0.75) +
                            geom_hline(yintercept = 0.9, linetype = "dashed", colour = "black", size = 0.5, alpha = 0.75) +
    
                            # Draw diamond shapes for mean values
                            geom_point(data = filter(allQMRA_graphmeans, info_organism == "Ecoli"  & endpoint_name == "Pinf"),
                                       aes(x = endpoint_value_subtract_mean, 
                                           y = endpoint_value_subtract_mean_yval, 
                                           colour = info_treatmenttype, 
                                           fill = info_treatmenttype),
                                       shape = 23, size = 2.5, stroke = 1.5
                                       ) +
    
                            # Define aesthetic values such as colour
                            theme_bw() +
                            scale_color_manual(values = brew_3) +
                            scale_fill_manual(values = fill_3) +
                            theme(legend.position = "none",
                                  text = element_text(size = 12), 
                                  axis.text.x = element_text(angle = 50, vjust = 1, hjust = 1),
                                  axis.title.x = element_text(size=12),
                                  panel.grid.minor = element_blank(), 
                                  strip.background = element_rect(fill = "white", color = NA),
                                  strip.text.x = element_text(colour = "white", hjust = 0, vjust = 1, size = 12)
                                  # NOTE: strip.text.x being set to white keeps the labels but turns the font white 
                                  # so that the plot sizing is unchanged but each facet row isn't labelled 3 times 
                                  # when we get to the patchwork step (below). Delete if you want the text back
                                  )
plot(plot_subtractendp_Pinf_c)




## Draw graph for DALYs
plot_subtractendp_DALY_c = ggplot() +
                            
                            # Plot ecdf lines for each lab-field data pair
                            stat_ecdf(data = filter(allQMRA_graph, info_organism == "Ecoli"  & endpoint_name == "DALY"), 
                                    aes(endpoint_value_subtract, 
                                        colour = info_treatmenttype, 
                                        group = info_pairnum), 
                                    geom = "step", linewidth = 0.15, alpha = 0.55) +
    
                            # Plot ecdf line for all data together
                            stat_ecdf(data = filter(allQMRA_graph, info_organism == "Ecoli"  & endpoint_name == "DALY"), 
                                    aes(endpoint_value_subtract, colour = info_treatmenttype),
                                    geom = "step", linewidth = 0.85, alpha = 1)+

                            # Create 3 panels, one for each treatment type (filter/chemical/UV)
                            facet_wrap( ~ info_treatmenttype, ncol = 1,
                                    labeller = labeller(info_treatmenttype = treatment_type_labs)) +
    
                            # Define scales 
                            scale_x_continuous(trans='pseudo_log',
                                       limits = c(-0.001, 0.002),
                                       breaks = c(-0.001, 0, 0.001, 0.002),
                                       minor_breaks = c(-0.0005, 0.0005, 0.0015),
                                       labels = c("-0.001", "0", "0.001", "0.002")
                                       ) +
                            scale_y_continuous(breaks = c(0.1, 0.5, 0.9), limits = c(0, NA)) +
    
                            # Define axis labels
                            xlab(paste("Difference in DALYs", "", "", sep = "")) +
                            ylab("") +
    
                            # Draw dashed lines at the 10% and 90% percentiles
                            geom_hline(yintercept = 0.1, linetype = "dashed", colour = "black", size = 0.5, alpha = 0.75) +
                            geom_hline(yintercept = 0.9, linetype = "dashed", colour = "black", size = 0.5, alpha = 0.75) +
    
                            # Draw diamond shapes for mean values
                            geom_point(data = filter(allQMRA_graphmeans, info_organism == "Ecoli"  & endpoint_name == "DALY"),
                                       aes(x = endpoint_value_subtract_mean, 
                                           y = endpoint_value_subtract_mean_yval, 
                                           colour = info_treatmenttype, 
                                           fill = info_treatmenttype),
                                       shape = 23, size = 2.5, stroke = 1.5
                                       ) +
    
                            # Define aesthetic values such as colour
                            theme_bw() +
                            scale_color_manual(values = brew_3) +
                            scale_fill_manual(values = fill_3) +
                            theme(legend.position = "none",
                                  text = element_text(size = 12), 
                                  axis.text.x = element_text(angle = 50, vjust = 1, hjust = 1),
                                  axis.title.x = element_text(size=12),
                                  panel.grid.minor = element_blank(), 
                                  strip.background = element_rect(fill = "white", color = NA),
                                strip.text.x = element_text(colour = "white", hjust = 0, vjust = 1, size = 12)
                                  # NOTE: strip.text.x being set to white keeps the labels but turns the font white 
                                  # so that the plot sizing is unchanged but each facet row isn't labelled 3 times 
                                  # when we get to the patchwork step (below). Delete if you want the text back)
                                  )
plot(plot_subtractendp_DALY_c)



# Put all 3 figures together with Patchwork
plot_subtractendp_all_c = plot_subtractendp_exposure_c + plot_subtractendp_Pinf_c + plot_subtractendp_DALY_c +
    plot_annotation(
        title = paste("Subtract endpoints between field-obtained", 
                      "and manufacturer-claimed LRV scenarios ",
                       sep = " "), 
        subtitle = expression(paste(italic("C. jejuni")))) & 
    theme(plot.title = element_text(size = 14, hjust = 0),    # Left-aligned
          plot.subtitle = element_text(size = 12, hjust = 0)) # Left-aligned
plot(plot_subtractendp_all_c)


# Save figure for publication
ggsave("output_QMRA/subtractendpoints_campy.png", 
        plot = plot_subtractendp_all_c,
        dpi = 300,
        width = 8.5,
        height = 11,
        units = "in")

```



## Giardia figure
```{r giardia figure, fig.width= 8, fig.height=11}


## Draw graph for exposure
plot_subtractendp_exposure_g = ggplot() +
                            
                            # Plot ecdf lines for each lab-field data pair
                            stat_ecdf(data = filter(allQMRA_graph, info_organism == "yeast"  & endpoint_name == "exposure"), 
                                    aes(endpoint_value_subtract, 
                                        colour = info_treatmenttype, 
                                        group = info_pairnum), 
                                    geom = "step", linewidth = 0.15, alpha = 0.55) +
    
                            # Plot ecdf line for all data together
                            stat_ecdf(data = filter(allQMRA_graph, info_organism == "yeast"  & endpoint_name == "exposure"), 
                                    aes(endpoint_value_subtract, colour = info_treatmenttype),
                                    geom = "step", linewidth = 0.85, alpha = 1)+

                            # Create 3 panels, one for each treatment type (filter/chemical/UV)
                            facet_wrap( ~ info_treatmenttype, ncol = 1,
                                    labeller = labeller(info_treatmenttype = treatment_type_labs)) +
    
                            # Define scales 
                            scale_x_continuous(trans='pseudo_log',
                                       limits = c(-0.005, 0.02)
                                       ) +
                            scale_y_continuous(breaks = c(0.1, 0.5, 0.9), limits = c(0, NA)) +
    
                            # Define axis labels
                            xlab(paste("Difference in dose", "", "", sep = "")) +
                            ylab("") +
    
                            # Draw dashed lines at the 10% and 90% percentiles
                            geom_hline(yintercept = 0.1, linetype = "dashed", colour = "black", size = 0.5, alpha = 0.75) +
                            geom_hline(yintercept = 0.9, linetype = "dashed", colour = "black", size = 0.5, alpha = 0.75) +
    
                            # Draw diamond shapes for mean values
                            geom_point(data = filter(allQMRA_graphmeans, info_organism == "yeast"  & endpoint_name == "exposure"),
                                       aes(x = endpoint_value_subtract_mean, 
                                           y = endpoint_value_subtract_mean_yval, 
                                           colour = info_treatmenttype, 
                                           fill = info_treatmenttype),
                                       shape = 23, size = 2.5, stroke = 1.5
                                       ) +
    
                            # Define aesthetic values such as colour
                            theme_bw() +
                            scale_color_manual(values = brew_3) +
                            scale_fill_manual(values = fill_3) +
                            theme(legend.position = "none",
                                  text = element_text(size = 12), 
                                  axis.text.x = element_text(angle = 50, vjust = 1, hjust = 1),
                                  axis.title.x = element_text(size=12),
                                  panel.grid.minor = element_blank(), 
                                  strip.background = element_rect(fill = "white", color = NA),
                                  strip.text.x = element_text(hjust = 0, vjust = 1, size = 12))
plot(plot_subtractendp_exposure_g)


## Draw graph for Pinf
plot_subtractendp_Pinf_g = ggplot() +
                            
                            # Plot ecdf lines for each lab-field data pair
                            stat_ecdf(data = filter(allQMRA_graph, info_organism == "yeast"  & endpoint_name == "Pinf"), 
                                    aes(endpoint_value_subtract, 
                                        colour = info_treatmenttype, 
                                        group = info_pairnum), 
                                    geom = "step", linewidth = 0.15, alpha = 0.55) +
    
                            # Plot ecdf line for all data together
                            stat_ecdf(data = filter(allQMRA_graph, info_organism == "yeast"  & endpoint_name == "Pinf"), 
                                    aes(endpoint_value_subtract, colour = info_treatmenttype),
                                    geom = "step", linewidth = 0.85, alpha = 1)+

                            # Create 3 panels, one for each treatment type (filter/chemical/UV)
                            facet_wrap( ~ info_treatmenttype, ncol = 1,
                                    labeller = labeller(info_treatmenttype = treatment_type_labs)) +
    
                            # Define scales 
                            scale_x_continuous(trans='pseudo_log',
                                       limits = c(-0.00025, 0.00075),
                                       breaks = c(-0.00025, 0, 0.00025, 0.0005, 0.00075),
                                       labels = c(expression(-2.5%.%10^{-4}),
                                           "0",
                                           expression(2.5%.%10^{-4}),
                                           expression(5.0%.%10^{-4}),
                                           expression(7.5%.%10^{-4}))
                                       ) +
                            scale_y_continuous(breaks = c(0.1, 0.5, 0.9), limits = c(0, NA)) +
    
                            # Define axis labels
                            xlab(paste("Difference in", "probability of infection", sep = "\n")) +
                            ylab("") +
    
                            # Draw dashed lines at the 10% and 90% percentiles
                            geom_hline(yintercept = 0.1, linetype = "dashed", colour = "black", size = 0.5, alpha = 0.75) +
                            geom_hline(yintercept = 0.9, linetype = "dashed", colour = "black", size = 0.5, alpha = 0.75) +
    
                            # Draw diamond shapes for mean values
                            geom_point(data = filter(allQMRA_graphmeans, info_organism == "yeast"  & endpoint_name == "Pinf"),
                                       aes(x = endpoint_value_subtract_mean, 
                                           y = endpoint_value_subtract_mean_yval, 
                                           colour = info_treatmenttype, 
                                           fill = info_treatmenttype),
                                       shape = 23, size = 2.5, stroke = 1.5
                                       ) +
    
                            # Define aesthetic values such as colour
                            theme_bw() +
                            scale_color_manual(values = brew_3) +
                            scale_fill_manual(values = fill_3) +
                            theme(legend.position = "none",
                                  text = element_text(size = 12), 
                                  axis.text.x = element_text(angle = 50, vjust = 1, hjust = 1),
                                  axis.title.x = element_text(size=12),
                                  panel.grid.minor = element_blank(), 
                                  strip.background = element_rect(fill = "white", color = NA),
                                  strip.text.x = element_text(colour = "white", hjust = 0, vjust = 1, size = 12)
                                  # NOTE: strip.text.x being set to white keeps the labels but turns the font white 
                                  # so that the plot sizing is unchanged but each facet row isn't labelled 3 times 
                                  # when we get to the patchwork step (below). Delete if you want the text back
                                  )
plot(plot_subtractendp_Pinf_g)



## Draw graph for DALYs
plot_subtractendp_DALY_g = ggplot() +
                            
                            # Plot ecdf lines for each lab-field data pair
                            stat_ecdf(data = filter(allQMRA_graph, info_organism == "yeast"  & endpoint_name == "DALY"), 
                                    aes(endpoint_value_subtract, 
                                        colour = info_treatmenttype, 
                                        group = info_pairnum), 
                                    geom = "step", linewidth = 0.15, alpha = 0.55) +
    
                            # Plot ecdf line for all data together
                            stat_ecdf(data = filter(allQMRA_graph, info_organism == "yeast"  & endpoint_name == "DALY"), 
                                    aes(endpoint_value_subtract, colour = info_treatmenttype),
                                    geom = "step", linewidth = 0.85, alpha = 1)+

                            # Create 3 panels, one for each treatment type (filter/chemical/UV)
                            facet_wrap( ~ info_treatmenttype, ncol = 1,
                                    labeller = labeller(info_treatmenttype = treatment_type_labs)) +
    
                            # Define scales 
                            scale_x_continuous(trans='pseudo_log',
                                       limits = c((-0.5*10^-7),
                                                  (1*10^-7)),
                                       breaks = c((-5*10^-8),
                                                  # (-1*10^-6),
                                                  0,
                                                  (5*10^-8),
                                                  (1*10^-7)),
                                       labels = c(
                                           expression(-5%.%10^{-8}),
                                           "0",
                                           expression(5%.%10^{-8}),
                                           expression(1%.%10^{-7}))
                                       ) +
                            scale_y_continuous(breaks = c(0.1, 0.5, 0.9), limits = c(0, NA)) +
    
                            # Define axis labels
                            xlab(paste("Difference in DALYs", "", "", sep = "")) +
                            ylab("") +
    
                            # Draw dashed lines at the 10% and 90% percentiles
                            geom_hline(yintercept = 0.1, linetype = "dashed", colour = "black", size = 0.5, alpha = 0.75) +
                            geom_hline(yintercept = 0.9, linetype = "dashed", colour = "black", size = 0.5, alpha = 0.75) +
    
                            # Draw diamond shapes for mean values
                            geom_point(data = filter(allQMRA_graphmeans, info_organism == "yeast"  & endpoint_name == "DALY"),
                                       aes(x = endpoint_value_subtract_mean, 
                                           y = endpoint_value_subtract_mean_yval, 
                                           colour = info_treatmenttype, 
                                           fill = info_treatmenttype),
                                       shape = 23, size = 2.5, stroke = 1.5
                                       ) +
    
                            # Define aesthetic values such as colour
                            theme_bw() +
                            scale_color_manual(values = brew_3) +
                            scale_fill_manual(values = fill_3) +
                            theme(legend.position = "none",
                                  text = element_text(size = 12), 
                                  axis.text.x = element_text(angle = 50, vjust = 1, hjust = 1),
                                  axis.title.x = element_text(size=12),
                                  panel.grid.minor = element_blank(), 
                                  strip.background = element_rect(fill = "white", color = NA),
                                strip.text.x = element_text(colour = "white", hjust = 0, vjust = 1, size = 12)
                                  # NOTE: strip.text.x being set to white keeps the labels but turns the font white 
                                  # so that the plot sizing is unchanged but each facet row isn't labelled 3 times 
                                  # when we get to the patchwork step (below). Delete if you want the text back)
                                  )
plot(plot_subtractendp_DALY_g)



# Put all 3 figures together with Patchwork
plot_subtractendp_all_g = plot_subtractendp_exposure_g + plot_subtractendp_Pinf_g + plot_subtractendp_DALY_g +
    plot_annotation(
        title = paste("Subtract endpoints between field-obtained", 
                      "and manufacturer-claimed LRV scenarios ",
                       sep = " "), 
        subtitle = expression(paste(italic("G. lamblia")))) & 
    theme(plot.title = element_text(size = 14, hjust = 0),    # Left-aligned
          plot.subtitle = element_text(size = 12, hjust = 0)) # Left-aligned
plot(plot_subtractendp_all_g)



# Save figure for publication
ggsave("output_QMRA/subtractendpoints_giardia.png", 
        plot = plot_subtractendp_all_g,
        dpi = 300,
        width = 8.5,
        height = 11,
        units = "in")


```


# QMRA summary tables for publication SI
## By treatment category: UV/filter/chemical
```{r summary tables}

### Data wrangling
## NOTE: This is a bit repeated from the chunk "wrangle data for figures" but I didn't want to use the same df so I'm redoing it here
# Wrangle data wider, to figure out the difference in lab vs field endpoints
allQMRA_forsummary = allQMRA_long %>%
    pivot_wider(                    # Pivot wider so that manuf - field can be calculated
        names_from = info_setting,
        values_from = c(endpoint_value, input_LRV)
    ) %>%
    dplyr::rename(                         # Rename columns to match our naming scheme
        endpoint_field = endpoint_value_field,
        endpoint_manuf = endpoint_value_manuf,
        LRV_field = input_LRV_field,
        LRV_manuf = input_LRV_manuf
        ) %>%
    dplyr::select(                  # Select the relevant columns
                  info_surveynum,
                  info_pairnum,
                  info_treatmenttype,
                  info_treatmentname,
                  info_organism,

                  LRV_field,
                  LRV_manuf,
                  
                  endpoint_name,
                  endpoint_field,
                  endpoint_manuf,
                  ) 
    
# Subtract endpoints to find the difference
# Take endpoint_field - endpoint_manuf
# and LRV_field - LRV_manuf
# So that if LRV_manuf > LRV_field, then the difference in health risk would be positive
# and difference in LRV would be negative
allQMRA_forsummary = allQMRA_forsummary %>%
    mutate(endpoint_subtract = endpoint_field - endpoint_manuf) %>%
    mutate(LRV_subtract = LRV_field - LRV_manuf, .after = LRV_manuf)


# Pivot_longer again, so that we can group_by setting
allQMRA_forsummary = allQMRA_forsummary %>%
  pivot_longer(cols = -c(info_surveynum, info_pairnum, info_treatmenttype, info_treatmentname, info_organism, endpoint_name),
               names_to = c(".value","location"),
               names_pattern = "(LRV|endpoint)_(manuf|field|subtract)",
               values_to = c("value", "type")) %>%
    
    dplyr::rename(                         # Rename columns to match our naming scheme
        endpoint_value = endpoint,
        LRV_value = LRV,
        info_setting = location
    )




### Calculate summary stats for summary table
summarytable_output = allQMRA_forsummary %>%
    # Group and calc stats
    dplyr::group_by(info_organism, info_setting, info_treatmenttype, endpoint_name) %>%      # Tell R to group means by these variables
    dplyr::summarise(
        nsurveys = n()/nMC, 
        endpoint_mean = mean(endpoint_value),                   # Get mean values
        endpoint_10 = quantile(endpoint_value, probs = 0.1),    # 10th percentile
        endpoint_50 = quantile(endpoint_value, probs = 0.5),    # 50th percentile (median)
        endpoint_90 = quantile(endpoint_value, probs = 0.9),     # 90th percentile 
        LRV_mean = mean(LRV_value)
    ) %>%

    # Pivot this table wider, so that each column contains an endpoint summary stat for exp/Pinf/DALY
    pivot_wider(
        names_from = endpoint_name,
        values_from = c(endpoint_mean, endpoint_10, endpoint_50, endpoint_90)
    ) %>%
    
    # Make a new column with proper pathogen names
    mutate(
        gt_organism = case_when(
                    info_organism == "Ecoli" ~ " C. jejuni",
                    info_organism == "yeast" ~ "G. lamblia"
        ), .after = info_organism
    ) %>%
    
    # Make another new column with proper setting names
    mutate(
        gt_setting = case_when(
                    info_setting == "field" ~ "Fieldwork 2021",
                    info_setting == "manuf" ~ "Manufacturer claim",
                    info_setting == "subtract" ~ "Difference between field and manufacturer"
        ), .after = info_setting
    ) %>%
    
    # Make another new column with proper treatment type names
    mutate(
        gt_treatmenttype = case_when(
            info_treatmenttype == "UV" ~ "UV",
            info_treatmenttype == "chemical" ~ "Chemical",
            info_treatmenttype == "filter" ~ "Filter"
        ), .after = info_treatmenttype
    )



### Make summary table using gt 
summarytable_output %>%
    # Wrangle data
    ungroup() %>%
    dplyr::select(-c(info_organism, info_setting, info_treatmenttype)) %>%
    
    # Tell it to do a gt table
    # Also specify to divide the table according to organism and setting
    gt(groupname_col = "gt_organism",
       rowname_col = "gt_setting"
    ) %>%
    
    # Scientific formatting
    fmt_scientific(
        columns = starts_with("endpoint"),
        decimals = 2
    ) %>%
    
    # Number formatting
    fmt_number(
        columns = LRV_mean,
        decimals = 2
    ) %>%

    
    # Make table spanners
    tab_spanner(
        label = "Dose",
        columns = ends_with("exposure")
    ) %>%
    tab_spanner(
        label = "Probability of infection",
        columns = ends_with("Pinf")
    ) %>%
    tab_spanner(
        label = "DALYs",
        columns = ends_with("DALY")
    ) %>%
    
    # Rename columns
    cols_label(
        gt_treatmenttype = "Treatment type",
        nsurveys = "Number of surveys",
        LRV_mean = "Mean LRV",
        
        endpoint_mean_exposure = "Mean",
        endpoint_10_exposure = "10th Percentile", 
        endpoint_50_exposure = "50th Percentile (Median)", 
        endpoint_90_exposure = "90th Percentile", 
        
        endpoint_mean_Pinf = "Mean",
        endpoint_10_Pinf = "10th Percentile", 
        endpoint_50_Pinf = "50th Percentile (Median)", 
        endpoint_90_Pinf = "90th Percentile", 
        
        endpoint_mean_DALY = "Mean",
        endpoint_10_DALY = "10th Percentile", 
        endpoint_50_DALY = "50th Percentile (Median)", 
        endpoint_90_DALY = "90th Percentile"

    ) %>%

    # Do aesthetics 
    cols_align(align = "left") %>%
    tab_style(
        style = cell_text(style = "italic"),
        locations = cells_row_groups(groups = c(1,2))
        ) %>%
    
    # Save
    gtsave("output_QMRA/summarytable.docx")



```




## By treatment device name (so 104 x 3 x 2 rows)
```{r summary tables by device name}

### Data wrangling
## NOTE: This is a bit repeated from the chunk "wrangle data for figures" but I didn't want to use the same df so I'm redoing it here
# Wrangle data wider, to figure out the difference in lab vs field endpoints
allQMRA_forsummary_treatmentdev  = allQMRA_long %>%
    pivot_wider(                    # Pivot wider so that manuf - field can be calculated
        names_from = info_setting,
        values_from = c(endpoint_value, input_LRV)
    ) %>%
    rename(                         # Rename columns to match our naming scheme
        endpoint_field = endpoint_value_field,
        endpoint_manuf = endpoint_value_manuf,
        LRV_field = input_LRV_field,
        LRV_manuf = input_LRV_manuf
        ) %>%
    dplyr::select(                  # Select the relevant columns
                  info_surveynum,
                  info_pairnum,
                  info_treatmenttype,
                  info_treatmentname,
                  info_organism,

                  LRV_field,
                  LRV_manuf,
                  
                  endpoint_name,
                  endpoint_field,
                  endpoint_manuf,
                  ) 
    
# Subtract endpoints to find the difference
# Take endpoint_field - endpoint_manuf
# and LRV_field - LRV_manuf
# So that if LRV_manuf > LRV_field, then the difference in health risk would be positive
# and difference in LRV would be negative
allQMRA_forsummary_treatmentdev  = allQMRA_forsummary_treatmentdev  %>%
    mutate(endpoint_subtract = endpoint_field - endpoint_manuf) %>%
    mutate(LRV_subtract = LRV_field - LRV_manuf, .after = LRV_manuf)


# Pivot_longer again, so that we can group_by setting
allQMRA_forsummary_treatmentdev  = allQMRA_forsummary_treatmentdev  %>%
  pivot_longer(cols = -c(info_surveynum, info_pairnum, info_treatmenttype, info_treatmentname, info_organism, endpoint_name),
               names_to = c(".value","location"),
               names_pattern = "(LRV|endpoint)_(manuf|field|subtract)",
               values_to = c("value", "type")) %>%
    
    rename(                         # Rename columns to match our naming scheme
        endpoint_value = endpoint,
        LRV_value = LRV,
        info_setting = location
    )




### Calculate summary stats for summary table
summarytable_output_treatmentdev = allQMRA_forsummary_treatmentdev %>%
    # Group and calc stats
    group_by(info_organism,               # Tell R to group means by these variables
             info_setting, 
             info_treatmenttype, 
             info_treatmentname, 
             endpoint_name) %>%
    summarise(
        n_datapoints = n()/nMC,                                 # Get the number of surveys with that respective device
        endpoint_mean = mean(endpoint_value),                   # Get mean values
        endpoint_10 = quantile(endpoint_value, probs = 0.1),    # 10th percentile
        endpoint_50 = quantile(endpoint_value, probs = 0.5),    # 50th percentile (median)
        endpoint_90 = quantile(endpoint_value, probs = 0.9),    # 90th percentile 
        LRV_mean = mean(LRV_value)                              # Get the mean LRV
    ) %>%
    pivot_wider(
        names_from = endpoint_name,
        values_from = c(endpoint_mean, endpoint_10, endpoint_50, endpoint_90)
    ) %>%
    
    # Make a new column with proper pathogen names
    mutate(
        gt_organism = case_when(
                    info_organism == "Ecoli" ~ " C. jejuni",
                    info_organism == "yeast" ~ "G. lamblia"
        ), .after = info_organism
    ) %>%
    
    # Make another new column with proper setting names
    mutate(
        gt_setting = case_when(
                    info_setting == "field" ~ "Fieldwork 2021",
                    info_setting == "manuf" ~ "Manufacturer claim",
                    info_setting == "subtract" ~ "Difference between field and manufacturer"
        ), .after = info_setting
    ) %>%
    
    # Make another new column with proper treatment type names
    mutate(
        gt_treatmenttype = case_when(
            info_treatmenttype == "UV" ~ "UV",
            info_treatmenttype == "chemical" ~ "Chemical",
            info_treatmenttype == "filter" ~ "Filter"
        ), .after = info_treatmenttype
    ) %>%
    
    # Make another new column with proper names for the treatment devices
    mutate(
        gt_treatmentname = case_when(
            info_treatmentname == "aquatabs" ~ "Aquatabs",
            info_treatmentname == "aquatabs_20L" ~ "Aquatabs, 20L",
            info_treatmentname == "grayl" ~ "Grayl",
            info_treatmentname == "katadyn_basecamppro10L" ~ "Katadyn Base Camp Pro, 10 L",
            info_treatmentname == "katadyn_befree" ~ "Katadyn BeFree", 
            info_treatmentname == "katadyn_hikerpro" ~ "Katadyn Hiker Pro",
            info_treatmentname == "katadyn_vario" ~ "Katadyn Vario",
            info_treatmentname == "lifestraw_flex" ~ "Lifestraw Flex",
            info_treatmentname == "miniwell_L630" ~ "Miniwell L630",
            info_treatmentname == "MSR_autoflow" ~ "MSR Autoflow",
            info_treatmentname == "MSR_guardian" ~ "MSR Guardian",
            info_treatmentname == "MSR_hyperflow" ~ "MSR Hyperflow",
            info_treatmentname == "MSR_miniworks" ~ "MSR Miniworks",
            info_treatmentname == "MSR_trailshot" ~ "MSR Trailshot",
            info_treatmentname == "platypus_gravityworks" ~ "Platypus GravityWorks",
            info_treatmentname == "printine_filter" ~ "Pristine Filter",
            info_treatmentname == "pristine_drops" ~ "Pristine Drops",
            info_treatmentname == "sawyer_microsqueeze" ~ "Sawyer Micro Squeeze",
            info_treatmentname == "sawyer_mini" ~ "Sawyer Mini",
            info_treatmentname == "sawyer_squeeze" ~ "Sawyer Squeeze",
            info_treatmentname == "steripen" ~ "SteriPen",
            info_treatmentname == "survivor_prox" ~ "Survivor Pro X",
            info_treatmentname == "versa_flow" ~ "Versa Flow"
        ), .after = info_treatmentname
    )



### Make summary table using gt 
summarytable_output_treatmentdev %>%
    # Wrangle data
    ungroup() %>%
    dplyr::select(-c(info_organism, info_setting, info_treatmenttype, info_treatmentname)) %>%
    
    # Tell it to do a gt table
    # Also specify to divide the table according to organism and setting
    gt(groupname_col = "gt_organism",
       rowname_col = "gt_setting"
    ) %>%
    
    # Scientific formatting
    fmt_scientific(
        columns = starts_with("endpoint"),
        decimals = 2
    ) %>%
    
    # Format LRV column
    fmt_number(
        columns = LRV_mean,
        decimals = 2
    ) %>%
    
    # Make table spanners
    tab_spanner(
        label = "Dose",
        columns = ends_with("exposure")
    ) %>%
    tab_spanner(
        label = "Probability of infection",
        columns = ends_with("Pinf")
    ) %>%
    tab_spanner(
        label = "DALYs",
        columns = ends_with("DALY")
    ) %>%
    
    # Rename columns
    cols_label(
        gt_treatmenttype = "Treatment type",
        gt_treatmentname = "Device name",
        n_datapoints = "Number of surveys",
        LRV_mean = "Mean LRV",
        
        endpoint_mean_exposure = "Mean",
        endpoint_10_exposure = "10th Percentile", 
        endpoint_50_exposure = "50th Percentile (Median)", 
        endpoint_90_exposure = "90th Percentile", 
        
        endpoint_mean_Pinf = "Mean",
        endpoint_10_Pinf = "10th Percentile", 
        endpoint_50_Pinf = "50th Percentile (Median)", 
        endpoint_90_Pinf = "90th Percentile", 
        
        endpoint_mean_DALY = "Mean",
        endpoint_10_DALY = "10th Percentile", 
        endpoint_50_DALY = "50th Percentile (Median)", 
        endpoint_90_DALY = "90th Percentile"

    ) %>%

    # Do aesthetics 
    cols_align(align = "left") %>%
    tab_style(
        style = cell_text(style = "italic"),
        locations = cells_row_groups(groups = c(1,2))
        ) %>%
    
    # Save
    gtsave("output_QMRA/summarytable_bytreatmentdevice.docx")


```


# Sensitivity analysis: Rough correlations analysis
```{r correlations analysis, fig.width= 11, fig.height=8}

### Data wrangling
# Wrangle data longer, so that the process column values are all one column
allQMRA_forcorr = allQMRA_long %>%
    rename(process_LRV = input_LRV) %>%  # Rename LRV column so it'll get pivoted 
    pivot_longer(
        cols = starts_with("process"),
        names_to = "process_name",
        values_to = "process_value",
        names_prefix = "process_"
    ) %>%
    
    # Filter out the endpoints that don't use Pillinf
    filter(
        !(process_name == "Pillinf" & endpoint_name == "exposure"),
        !(process_name == "Pillinf" & endpoint_name == "Pinf")
    )



### Correlations
# Calculate
corr_summ = allQMRA_forcorr %>%
    # Wrangle
    group_by(info_organism, process_name, endpoint_name) %>%
    
    # Make corr and R2 calculations
    summarize(
        corr = cor(process_value, endpoint_value, method = "sp"), 
        R2 = corr^2
    ) 


# Wrangle for gt table
corr_summ_gt = corr_summ %>%
    # Make a new column with proper pathogen names
    mutate(
        gt_organism = case_when(
                    info_organism == "Ecoli" ~ " C. jejuni",
                    info_organism == "yeast" ~ "G. lamblia"
        ), .after = info_organism
    ) %>%
    
    # Make new column with proper endpoint names
    mutate(
        gt_endpoint_name = case_when(
            endpoint_name == "exposure" ~ "Exposure",
            endpoint_name == "Pinf" ~ "Probability of infection",
            endpoint_name == "DALY" ~ "DALYs"
        ), .after = endpoint_name
    ) %>%
    
    # Make new column with input variable names and units
    mutate(
        gt_process_name = case_when(
           process_name == "DWvoltrip" ~ "Total drinking water consumed (L)",
           process_name == "LRV" ~ "LRV (unitless)",
           process_name == "Pillinf" ~ "Probability of illness given infection (unitless)",
           process_name == "rawWQtrip" ~ "Total raw water pathogen concentration (CFU or oocysts/L)"
        ), .after = process_name
    )
    
    

# Make summary table
corr_summ_gt %>%
    # Wrangle
    ungroup() %>%
    dplyr::select(-c(R2, info_organism, endpoint_name, process_name)) %>%
    group_by(gt_organism) %>%
    
    # Make table
    gt() %>%
    
    # Move endpoint_name column to the front
    cols_move_to_start(
        columns = gt_endpoint_name
    ) %>%
    
    # Format corr column
    fmt_number(
        columns = c(corr),
        decimals = 4
    ) %>%
    
    # Rename columns
    cols_label(
        gt_endpoint_name = "QMRA endpoint",
        gt_process_name = "Input variable (units)",
        corr = "Spearman correlation, rho"
    ) %>%

    # Do aesthetics 
    cols_align(align = "left") %>%
    tab_style(
        style = cell_text(style = "italic"),
        locations = cells_row_groups()
        ) 
    
    # Save
    # gtsave("output_QMRA/summarytable_corr.docx")


### Graphing
# Initialize colour aesthetics
brew_3 = c("#A50026", "#FC8D59", "#4575B4")
fill_3 = c("#DB99A8","#FED1BD","#B5C8E1")

# Make labels
allQMRA_forcorr$endpoint_name = factor(allQMRA_forcorr$endpoint_name,
                                       levels = c("exposure", "Pinf", "DALY"), 
                                       labels = c("Exposure (#/L)",
                                                  "Probability of illness (unitless)",
                                                  "DALYs"))
allQMRA_forcorr$process_name = factor(allQMRA_forcorr$process_name, 
                                      levels = c("rawWQtrip", "LRV", "DWvoltrip", "Pillinf"),
                                      labels = c(paste("Total raw water pathogen", "concentration (#/L)", sep = "\n"),
                                                 "LRV (unitless)",
                                                 paste("Total drinking water", "consumed (L)", sep = "\n"),
                                                 paste("Probability of illness", "given infection (unitless)", sep = "\n")))

# Campylobacter
corr_plot_campy = ggplot(data = filter(allQMRA_forcorr, info_organism == "Ecoli"),
                         aes(x = process_value, y = endpoint_value, colour = endpoint_name)) +
    geom_point(size = 1, alpha = 0.5) +
    geom_line(stat = "smooth", 
              method = "lm", 
              alpha = 1, 
              size = 1) +
    facet_grid(endpoint_name ~ process_name, 
               scales = "free",
               switch = "y") +
    theme_bw() +
    scale_color_manual(values = brew_3) +
    theme(axis.title = element_blank(),
          # panel.spacing.x = unit(1,"lines"), 
          legend.position = "none",
          text = element_text(size = 12), 
          axis.text.x = element_text(angle = 50, vjust = 1, hjust = 1),
          panel.grid.minor = element_blank(), 
          strip.background = element_rect(fill = "white", color = NA),
          strip.text.x = element_text(size = 12),
          strip.text.y = element_text(size = 12)
          ) +
    scale_y_continuous(position = "right")
    
plot(corr_plot_campy)

# Save figure for publication
ggsave("output_QMRA/correlationplot_campy.png", 
        plot = corr_plot_campy,
        dpi = 300,
        width = 11,
        height = 8.5,
        units = "in")


# Giardia
corr_plot_giardia = ggplot(data = filter(allQMRA_forcorr, info_organism == "yeast"),
                         aes(x = process_value, y = endpoint_value, colour = endpoint_name)) +
    geom_point(size = 1, alpha = 0.5) +
    geom_line(stat = "smooth", 
              method = "lm", 
              alpha = 1, 
              size = 1) +
    facet_grid(endpoint_name ~ process_name, 
               scales = "free",
               switch = "y") +
    theme_bw() +
    scale_color_manual(values = brew_3) +
    theme(axis.title = element_blank(),
          # panel.spacing.x = unit(1,"lines"), 
          legend.position = "none",
          text = element_text(size = 12), 
          axis.text.x = element_text(angle = 50, vjust = 1, hjust = 1),
          panel.grid.minor = element_blank(), 
          strip.background = element_rect(fill = "white", color = NA),
          strip.text.x = element_text(size = 12),
          strip.text.y = element_text(size = 12)
          ) +
    scale_y_continuous(position = "right")
    
plot(corr_plot_giardia)

# Save figure for publication
ggsave("output_QMRA/correlationplot_giardia.png", 
        plot = corr_plot_giardia,
        dpi = 300,
        width = 11,
        height = 8.5,
        units = "in")

```



# Tornado plots

## Make function to do a deterministic QMRA based on point-value inputs
```{r deterministic QMRA}

### Make function to calculate QMRA endpoints based on point-value inputs that were stochastic in our overall QMRA model
# Inputs:
#   rawpathconc = the pathogen concentration in the raw water, in organisms/L
#   DWvol = the volume of water consumed in each refill (21 refills per 7-day backpacking trip), in L
#   LRV = the treatment device LRV with respect to each pathogen, unitless
#   Pillinf = the probability of illness given infection with a pathogen, unitless
#   microbe: either "campy" or "giardia"

# Outputs:
#   det_QMRA: A 7 x 1 tibble containing all the calculated deterministic endpoints (trip exposure, Pinf on the trip, DALYs per trip)
#             as well as the inputs (rawpathconc, DWvol, LRV, Pillinf)

# Process variables (were point-value in our overall QMRA model):
#   Dose-response relationship: For campylobacter, Pinf follows an approximate Beta-Poisson model with alpha = 0.144 and N50 = 890, per Medema (1996). For giardia, Pinf follows an exponential model with r = 0.0199, per Rose (1991)
#   DALY weight (DALY_weight): DALYS per illness, for campylobacter is 4.6E-3, and for giardia is 1.7E-3, per USEPA (2010)
#   Susceptible fraction (S): Susceptible fraction of the population, 100% for both campylobacter and giradia

FUN_detQMRA = function(rawpathconc, DWvol, LRV, Pillinf, microbe){
    
    # For troubleshooting
    # rawpathconc = 10
    # DWvol = 0.5
    # LRV = 2
    # Pillinf = 0.2
    # microbe = "giardia"
    
    ### Endpoint 1: overall trip exposure
    # Calculate the exposure per refill
    survival_frac = 10^(-1*LRV)     # Units are a % of the number of pathogens in the raw water (unitless)
    DW_conc_refill = rawpathconc * survival_frac * DWvol     # The number of pathogens in each refill (units of # pathogens)
    
    # Calculate the exposure over the 7-day trip (21 refills) --> First endpoint
    exposure_trip = DW_conc_refill * 7    # Units of # pathogens/7-day trip
    
    
    ### Endpoint #2: Probability of infection
    #   a: Use dose-response calculation for each refill
    if(microbe == "campy"){  
        # Campylobacter dose-response
        Pinf_refill = Pinf_c(exposure = exposure_trip, plotsdisp = F)
    } else {
        # Giardia dose-response
        Pinf_refill = Pinf_g(exposure = exposure_trip, plotsdisp = F)
    }
    #   b: Calculate the overall Pinf for the trip --> second endpoint
    Pinf_trip = 1 - (1 - Pinf_refill)^21
    
    
    ### Endpoint #3: DALYs per 7-day trip
    #    a: Calculate the Pill, using Pillinf
    Pill_trip = Pinf_trip * Pillinf
    
    #    b: Determine DALY weighting, depending on if campy or giardia
    if(microbe == "campy"){ 
        DALY_weight = 4.6E-3
    } else {
        DALY_weight = 1.7E-3
    }
    
    #    c: Calculate DALYs (units of YLL)
    DALY_trip = calcDALYs(Pill_trip = Pill_trip, 
                          S = 1,       # 100% susceptibility 
                          DW = DALY_weight, 
                          n_campingtrips = 1,   # One camping trip
                          plotsdisp = F)
    
    
    ### Wrangle outputs
    det_QMRA = tibble(microbe, rawpathconc, DWvol, LRV, Pillinf,          # Inputs
                    exposure_trip, Pinf_trip, DALY_trip) %>%              # Endpoints
        dplyr::rename(
            info_organism = microbe,
            input_rawpathconc = rawpathconc,
            input_DWvol = DWvol,
            input_LRV = LRV,
            input_Pillinf = Pillinf,

            endpoint_exposure = exposure_trip,
            endpoint_Pinf = Pinf_trip,
            endpoint_DALY = DALY_trip
        )
    
    # Output
    return(det_QMRA)
    
    
}



try_detQMRA = FUN_detQMRA(rawpathconc = 10, 
                      DWvol = 0.5,
                      LRV = 2,
                      Pillinf = 0.2,
                      microbe = "giardia")

```



## Make function to take the 10,000 MC-drawn inputs and figure out the percentile information
```{r pull percentile information from MC-drawn inputs}

### Make function to take our QMRA model inputs and figure out what the percentile information is

# Inputs:
#   allQMRA = a 13 x 4,180,000 dataframe with the QMRA results (see the chunk "cycle through all manuf-field LRV pairs")
#   percentile = a decimal value for the percentile that is to be calculated (i.e., 0.9 for the 90th/10th percentiles)

# Outputs:
#   input_percentiles: a 3 x 8 dataframe containing the input_name (the name of the input value), the input_value (the value itself), and percentile (what percentile we're looking at, and also the 50th percentile or median) 

FUN_inputpercentiles = function(QMRAdf, percentile){
    
    oneminuspercentile = 1 - percentile
    
    ### Get percentiles
    # Get df for campy and giardia
    QMRAdf_campy = filter(QMRAdf, QMRAdf$info_organism == "Ecoli")
    QMRAdf_giardia = filter(QMRAdf, QMRAdf$info_organism == "yeast")
    
    ## Raw water conc percentiles (total throughout the trip) 
    # Campy
    upper_rawpathconc_campy = quantile(QMRAdf_campy$process_rawWQtrip, probs = percentile)
    mid_rawpathconc_campy = quantile(QMRAdf_campy$process_rawWQtrip, probs = 0.5)
    lower_rawpathconc_campy = quantile(QMRAdf_campy$process_rawWQtrip, probs = oneminuspercentile)
    # Giardia
    upper_rawpathconc_giardia = quantile(QMRAdf_giardia$process_rawWQtrip, probs = percentile)
    mid_rawpathconc_giardia = quantile(QMRAdf_giardia$process_rawWQtrip, probs = 0.5)
    lower_rawpathconc_giardia = quantile(QMRAdf_giardia$process_rawWQtrip, probs = oneminuspercentile)
    
    
    ## Total drinking water volume over the trip
    upper_DWvol = quantile(QMRAdf$process_DWvoltrip, probs = percentile)
    mid_DWvol = quantile(QMRAdf$process_DWvoltrip, probs = 0.5)
    lower_DWvol = quantile(QMRAdf$process_DWvoltrip, probs = oneminuspercentile)
    
    ## LRV
    # Campy
    upper_LRV_campy = quantile(QMRAdf_campy$input_LRV, probs = percentile)
    mid_LRV_campy = quantile(QMRAdf_campy$input_LRV, probs = 0.5)
    lower_LRV_campy = quantile(QMRAdf_campy$input_LRV, probs = oneminuspercentile)
    # Giardia
    upper_LRV_giardia = quantile(QMRAdf_giardia$input_LRV, probs = percentile)
    mid_LRV_giardia = quantile(QMRAdf_giardia$input_LRV, probs = 0.5)
    lower_LRV_giardia = quantile(QMRAdf_giardia$input_LRV, probs = oneminuspercentile)
    
    
    ## Probability of illness given infection 
    # Campy
    upper_Pillinf_campy = quantile(QMRAdf_campy$process_Pillinf, percentile)
    mid_Pillinf_campy = quantile(QMRAdf_campy$process_Pillinf, 0.5)
    lower_Pillinf_campy = quantile(QMRAdf_campy$process_Pillinf, oneminuspercentile)
    # Giardia
    upper_Pillinf_giardia = quantile(QMRAdf_giardia$process_Pillinf, percentile)
    mid_Pillinf_giardia = quantile(QMRAdf_giardia$process_Pillinf, 0.5)
    lower_Pillinf_giardia = quantile(QMRAdf_giardia$process_Pillinf, oneminuspercentile)
    
    
    ### Wrangle outputs
    # Make nice tibble
    info_organism = c(rep("campy", 12), rep("giardia", 12))
    input_name = rep(c(rep("rawpathconc", 3),
                       rep("DWvol", 3),
                       rep("LRV", 3),
                       rep("Pillinf", 3)), 2)
    input_value = c(upper_rawpathconc_campy, mid_rawpathconc_campy, lower_rawpathconc_campy,   # Campy values
                    upper_DWvol, mid_DWvol, lower_DWvol, 
                    upper_LRV_campy, mid_LRV_campy, lower_LRV_campy, 
                    upper_Pillinf_campy, mid_Pillinf_campy, lower_Pillinf_campy,
                    
                    upper_rawpathconc_giardia, mid_rawpathconc_giardia, lower_rawpathconc_giardia,   # Giardia values
                    upper_DWvol, mid_DWvol, lower_DWvol, 
                    upper_LRV_giardia, mid_LRV_giardia, lower_LRV_giardia, 
                    upper_Pillinf_giardia, mid_Pillinf_giardia, lower_Pillinf_giardia
                    )
    percentile_values = c(rep(c(percentile, 0.5, oneminuspercentile), 8))
    nicepercentiles = tibble(info_organism, input_name, input_value, percentile_values)
    print(nicepercentiles)
    
    ## Make actual tibble that will go into a for loop later
    # Campy
    rawpathconc_campy = c(mid_rawpathconc_campy, upper_rawpathconc_campy, lower_rawpathconc_campy, rep(mid_rawpathconc_campy, 8))
    DWvol = c(rep(mid_DWvol, 3), upper_DWvol, lower_DWvol, rep(mid_DWvol, 6))
    LRV_campy = c(rep(mid_LRV_campy, 5), upper_LRV_campy, lower_LRV_campy, rep(mid_LRV_campy, 4))
    Pillinf_campy = c(rep(mid_Pillinf_campy, 7), upper_Pillinf_campy, lower_Pillinf_campy, rep(mid_Pillinf_campy, 2))
    info_organism_campy = c(rep("campy", 11))
    input_percentiles_campy = tibble(rawpathconc_campy, DWvol, LRV_campy, Pillinf_campy, info_organism_campy) %>%
        dplyr::rename(input_rawpathconc = rawpathconc_campy,
               input_DWvol = DWvol,
               input_LRV = LRV_campy, 
               input_Pillinf = Pillinf_campy,
               info_organism = info_organism_campy)
    
    # Giardia
    rawpathconc_giardia = c(mid_rawpathconc_giardia, upper_rawpathconc_giardia, lower_rawpathconc_giardia, rep(mid_rawpathconc_giardia, 8))
    LRV_giardia = c(rep(mid_LRV_giardia, 5), upper_LRV_giardia, lower_LRV_giardia, rep(mid_LRV_giardia, 4))
    Pillinf_giardia = c(rep(mid_Pillinf_giardia, 7), upper_Pillinf_giardia, lower_Pillinf_giardia, rep(mid_Pillinf_giardia, 2))
    info_organism_giardia = c(rep("giardia", 11))
    input_percentiles_giardia = tibble(rawpathconc_giardia, DWvol, LRV_giardia, Pillinf_giardia, info_organism_giardia) %>%
            dplyr::rename(input_rawpathconc = rawpathconc_giardia,
                   input_DWvol = DWvol,
                   input_LRV = LRV_giardia, 
                   input_Pillinf = Pillinf_giardia,
                   info_organism = info_organism_giardia)
    
    # Make overall tibble
    input_percentiles = rbind(input_percentiles_campy, input_percentiles_giardia)
    
    # Return tibble
    return(input_percentiles)
    
}

tryinputpercentiles = FUN_inputpercentiles(QMRAdf = allQMRA,
                                          percentile = 0.95)

```



## Make for loop to calculate the deterministic QMRA endpoints for each row in the inputpercentiles dataframe
```{r for loop to calculate deterministic QMRA endpoints}

### Make a for loop to calculate a determinstic QMRA based on the inputs of each row of the inputpercentiles dataframe

# Initialize the QMRA inputs based on the desired percentile
inputpercentiles = FUN_inputpercentiles(QMRAdf = allQMRA,
                                          percentile = 0.95)

### Function to do a for loop that calculates the deterministic QMRA endpoints for each row of the inputpercentiles df

# Inputs:
#  inputpercentiles: df calculated in the function FUN_inputpercentiles, contains point-value inputs for the deterministic QMRA

# Outputs:
#  detQMRA: A df containing the results of all deterministic QMRAs calculated for each row of inputpercentiles

# NOTE: calls the function FUN_detQMRA for each row

FUN_forloop_detQMRA = function(inputpercentiles){


    # Initialize tibble 
    detQMRA = tibble()
    
    
    # For loop here
    for(i in 1:nrow(inputpercentiles)) {
        
        # Check
        print(i)
    
        # Initialize row i
        row <- inputpercentiles[i,]
        
        # Do QMRA
        row_QMRA = FUN_detQMRA(
            rawpathconc = row$input_rawpathconc,
            DWvol = row$input_DWvol,
            LRV = row$input_LRV,
            Pillinf = row$input_Pillinf,
            microbe = row$info_organism
        )
        
        detQMRA = rbind(detQMRA, row_QMRA)
    
    }
    
    return(detQMRA)

}

detQMRA = FUN_forloop_detQMRA(inputpercentiles = inputpercentiles)

```

## A function to wrangle tornado plot data
```{r Function to wrangle data for tornado plot}

### Function to get and wrangle data from the deterministic QMRA for input to a tornado plot

# Inputs:
#  detQMRA: the dataframe of deterministic QMRA endpoints calculated for a specific percentile of inputs, see function FUN_forloop_detQMRA
#  select_organism: string value, should be either "campy" or "giardia"
#  epname: the name of the desired endpoint, should be either "endpoint_exposure", "endpoint_Pinf" or "endpoint_DALY"

# Outputs:
#  tornadodata: dataframe to be passed to the function FUN_maketornadoplot to make the tornado plots


FUN_gettornadodata = function(detQMRA, select_organism, epname){
    
    # Set things to troubleshoot function
    # detQMRA = detQMRA
    # select_organism = "giardia"
    # epname = "endpoint_exposure"
    
    # Subset the QMRAdf 
    detQMRA_select = detQMRA %>%
        filter(info_organism == select_organism)
    
    # Get max/min endpoint values for max/min rawpathconc values
    max_rawpathconc = max(detQMRA_select$input_rawpathconc)
    min_rawpathconc = min(detQMRA_select$input_rawpathconc)
    max_ep_rawpathconc = as.numeric(detQMRA_select[detQMRA_select$input_rawpathconc == max_rawpathconc, epname])
    min_ep_rawpathconc = as.numeric(detQMRA_select[detQMRA_select$input_rawpathconc == min_rawpathconc, epname])
    
    # Get max/min endpoint values for max/min DWvol values
    max_DWvol = max(detQMRA_select$input_DWvol)
    min_DWvol = min(detQMRA_select$input_DWvol)
    max_ep_DWvol = as.numeric(detQMRA_select[detQMRA_select$input_DWvol == max_DWvol, epname])
    min_ep_DWvol = as.numeric(detQMRA_select[detQMRA_select$input_DWvol == min_DWvol, epname])
    
    # Get max/min endpoint values for max/min LRV values
    max_LRV = max(detQMRA_select$input_LRV)
    min_LRV = min(detQMRA_select$input_LRV)
    max_ep_LRV = as.numeric(detQMRA_select[detQMRA_select$input_LRV == max_LRV, epname])
    min_ep_LRV = as.numeric(detQMRA_select[detQMRA_select$input_LRV == min_LRV, epname])
    
    # Get max/min endpoint values for max/min Pillinf values
    max_Pillinf = max(detQMRA_select$input_Pillinf)
    min_Pillinf = min(detQMRA_select$input_Pillinf)
    max_ep_Pillinf = as.numeric(detQMRA_select[detQMRA_select$input_Pillinf == max_Pillinf, epname])
    min_ep_Pillinf = as.numeric(detQMRA_select[detQMRA_select$input_Pillinf == min_Pillinf, epname])
    
    # Get the base case endpoint value for all inputs at 50th percentils
    base_ep = as.numeric(detQMRA_select[1,epname])
    base_ep_col = c(rep(base_ep, 4))
    
    # Wrangle data
    lower_endpoint = c(min_ep_rawpathconc, min_ep_DWvol, min_ep_LRV, min_ep_Pillinf)
    upper_endpoint = c(max_ep_rawpathconc, max_ep_DWvol, max_ep_LRV, min_ep_Pillinf)
    input_name = c("rawpathconc", "DWvol", "LRV", "Pillinf")
    
    # Make tibble
    tornadodata = tibble(lower_endpoint, upper_endpoint, base_ep_col, input_name)

    # Add columns to tornadodata to make plotting easier in the next function
    tornadodata = tornadodata %>%
        # Add column for the difference between upper and lower endpoint values
        mutate(ul_diff = upper_endpoint - lower_endpoint) %>% 
        
        # Add column with the endpoint name for clarity
        mutate(epname = epname) %>%
        
        # Add column with the selected organism for clarity
        mutate(info_organism = select_organism) %>%
        
        # Make column for naming the inputs
        mutate(
            input_name_plot = case_when(
                input_name == "rawpathconc" ~ "Raw pathogen concentration",
                input_name == "DWvol" ~ "Volume of water consumed",
                input_name == "LRV" ~ "Device LRV",
                input_name == "Pillinf" ~ "Probability of illness given infection"
            )
        ) 
        
        
        
    # Delete the row for Pillinf as an input, if the endpoint is exposure or Pinf
    if(epname == "endpoint_exposure" | epname == "endpoint_Pinf"){  
        # Delete the row for Pillinf as an input
        tornadodata = tornadodata %>%
            filter(input_name != "Pillinf")
    } else {
        # Keep Pillinf
        # print("do nothing")
    }
    
    # Return output
    return(tornadodata)
    
}

trytornadodata = FUN_gettornadodata(detQMRA = detQMRA, 
                                    select_organism = "campy", 
                                    epname = "endpoint_exposure")

```



## A function to make tornado plot
```{r Function to make tornado plot}

### Function to plot a single tornado plot

# Inputs:
#  tornadodata: data for the tornado plot, from function FUN_gettornadodata

# Outputs:
#  tornadoplot: a ggplot item that is a single tornado plot based on tornadodata



FUN_maketornadoplot = function(tornadodata){
    
    # For troubleshooting
    # tornadodata = trytornadodata
    
    # Define width of columns
    width = 0.95
    
    # Get bar order 
    tornado_order = tornadodata %>%
        arrange(ul_diff) %>%     # Put ascending order by the difference between lower and upper endpoints
        mutate(input_name_plot = factor(x = input_name_plot, levels = input_name_plot)) %>%   # Encode this order into the input_name factor
        dplyr::select(input_name_plot) %>%    # Grab the input_name
        unlist() %>%    # Make it into a vector of chr
        levels()        # This too
    
    
    ## Wrangle dataframe for plotting
    tornadodata_plot = tornadodata %>%
        # Pivot longer so that the endpoint values are all one column
        pivot_longer(               
            cols = ends_with("endpoint"),
            names_to = "endpoint_type",
            values_to = "endpoint_value"
        ) %>%
        
        # Make input_name a factor and order it
        mutate(input_name_plot = factor(input_name_plot, levels = tornado_order)) %>%
        
        # Calculate the coordinates of each rectangle
        mutate(
            ymin = pmin(endpoint_value, base_ep_col),
            ymax = pmax(endpoint_value, base_ep_col), 
            xmin = as.numeric(input_name_plot) - width/2,
            xmax = as.numeric(input_name_plot) + width/2
        ) %>%
        
        # Make column for naming the legend
        mutate(
            endpoint_type_plot = case_when(
                endpoint_type == "lower_endpoint" ~ "Decreased input",
                endpoint_type == "upper_endpoint" ~ "Increased input"
            )
        )
    
    
    
    ## Plot
    
    # Define colours
    brew_2 = c("#A50026", "#4575B4")
    
    # Pull the value for organism name for if/else
    microbe = tornadodata$info_organism[1]
    
    
    # Delete y axis labels if it's a giardia plot, so that when we patchwork it later, they're not repeated
    if(microbe == "campy"){  
        # Campylobacter plots, keep y axis labels
        
        tornadoplot = ggplot() +
            
            # Make main geom
            geom_rect(data = tornadodata_plot, 
                      aes(ymax = ymax, ymin = ymin, 
                          xmin = xmin, xmax = xmax, 
                          fill = endpoint_type_plot)) +
            geom_hline(yintercept = tornadodata_plot$base_ep_col[1]) +
            
            # Order bars in ascending order and set labels
            scale_x_continuous(breaks = c(1:length(tornado_order)),
                               labels = tornado_order) + 
    
            # Make it look nice
            coord_flip() + 
            theme_bw() +
            theme(legend.position = "none",
                  text = element_text(size = 12), 
                  axis.title.y = element_text(size=12),
                  panel.grid.minor = element_blank(), 
                  legend.title= element_blank()) +
            scale_fill_manual(values = brew_2)
        
        
    } else {
        # Giardia plots, delete y axis labels
        
        tornadoplot = ggplot() +
            
            # Make main geom
            geom_rect(data = tornadodata_plot, 
                      aes(ymax = ymax, ymin = ymin, 
                          xmin = xmin, xmax = xmax, 
                          fill = endpoint_type_plot)) +
            geom_hline(yintercept = tornadodata_plot$base_ep_col[1]) +
            
            # Order bars in ascending order
            scale_x_continuous(breaks = c(1:length(tornado_order))) + 
    
            # Make it look nice
            coord_flip() + 
            theme_bw() +
            theme(legend.position = "none",
                  text = element_text(size = 12), 
                  # axis.title.y = element_text(size=12),
                  axis.text.y = element_blank(),
                  panel.grid.minor = element_blank(), 
                  legend.title= element_blank()) +
            scale_fill_manual(values = brew_2)    
        }

    
    # Plot and return
    plot(tornadoplot)
    return(tornadoplot)
    
}

# Make sure the function works
trytornadoplot = FUN_maketornadoplot(tornadodata = trytornadodata)

```


## Put together 6 tornado plots for a given percentile using patchwork
```{r patchwork tornado plots, fig.width= 8, fig.height=11}

### Function to make 6 tornado plots and put them together using patchwork

# Inputs:
#  detQMRA: df with all the results of the deterministic QMRA done using inputs at a given percentile. See function FUN_forloop_detQMRA for how detQMRA is generated

# Outputs: 
#  patch_both: a patchwork/ggplot object that has 6 tornado plots (2 columns of 3, left column for campy and the right for giardia)

# Note: This function also calls the functions FUN_gettornadodata to get the input data for each individual tornado plot, and FUN_maketornadoplot to make ech individual plot



FUN_maketornadopatchwork = function(detQMRA){

    # For troubleshooting
    # detQMRA = detQMRA_80
    
    ### Make the tornado plots 

    ## Campylobacter
    # Campy, exposure
    tornadodata_c_exposure = FUN_gettornadodata(detQMRA = detQMRA, 
                                                   select_organism = "campy", 
                                                   epname = "endpoint_exposure")
    tornadoplot_c_exposure = FUN_maketornadoplot(tornadodata = tornadodata_c_exposure) + 
        ggtitle("Exposure: C. jejuni") +
        theme(plot.title = element_text(size = 12))
    
    # Campy, Pinf
    tornadodata_c_Pinf = FUN_gettornadodata(detQMRA = detQMRA, 
                                                   select_organism = "campy", 
                                                   epname = "endpoint_Pinf")
    tornadoplot_c_Pinf = FUN_maketornadoplot(tornadodata = tornadodata_c_Pinf) +
        ggtitle("Probability of infection: C. jejuni") +
        theme(plot.title = element_text(size = 12))
    
    # Campy, DALY
    tornadodata_c_DALY = FUN_gettornadodata(detQMRA = detQMRA, 
                                                   select_organism = "campy", 
                                                   epname = "endpoint_DALY")
    tornadoplot_c_DALY = FUN_maketornadoplot(tornadodata = tornadodata_c_DALY) +
        ggtitle("DALYs: C. jejuni") +
        theme(plot.title = element_text(size = 12))
    
    
    ## Giardia
    # Giardia, exposure
    tornadodata_g_exposure = FUN_gettornadodata(detQMRA = detQMRA, 
                                                   select_organism = "giardia", 
                                                   epname = "endpoint_exposure")
    tornadoplot_g_exposure = FUN_maketornadoplot(tornadodata = tornadodata_g_exposure) +
        ggtitle("G. lamblia") +
        theme(plot.title = element_text(size = 12))
    
    # Giardia, Pinf
    tornadodata_g_Pinf = FUN_gettornadodata(detQMRA = detQMRA, 
                                                   select_organism = "giardia", 
                                                   epname = "endpoint_Pinf")
    tornadoplot_g_Pinf = FUN_maketornadoplot(tornadodata = tornadodata_g_Pinf) +
        ggtitle("G. lamblia") +
        theme(plot.title = element_text(size = 12))
    
    # Giardia, DALY
    tornadodata_g_DALY = FUN_gettornadodata(detQMRA = detQMRA, 
                                                   select_organism = "giardia", 
                                                   epname = "endpoint_DALY")
    tornadoplot_g_DALY = FUN_maketornadoplot(tornadodata = tornadodata_g_DALY) +
        ggtitle("G. lamblia") +
        theme(plot.title = element_text(size = 12))
    
    
    ## Patchwork them together
    patch_both = (tornadoplot_c_exposure + tornadoplot_g_exposure) /
                 (tornadoplot_c_Pinf + tornadoplot_g_Pinf) /
                 (tornadoplot_c_DALY + tornadoplot_g_DALY) 
                 
    plot(patch_both)
    return(patch_both)

}

# Try the function
patch_both_try = FUN_maketornadopatchwork(detQMRA = detQMRA) 

```


## Make tornado plots, 20th to 80th percentiles
```{r tornado plots for 20th to 80th percentiles, fig.width= 8, fig.height=11}

### Step 1: Pull percentile information from QMRA
inputpercentiles_80 = FUN_inputpercentiles(QMRAdf = allQMRA,
                                          percentile = 0.8)

### Step 2: Calculate a deterministic QMRA for each row of inputpercentiles
detQMRA_80 = FUN_forloop_detQMRA(inputpercentiles = inputpercentiles_80)
# Change one value of the giardia LRVs to 2.99999 (instead of 3) because the 20th percentile LRV is the same as the median
detQMRA_80$input_LRV[18] = 2.999


### Step 3: Make tornado plots
patch_both_80 = FUN_maketornadopatchwork(detQMRA = detQMRA_80) +
                    plot_annotation(
                           title = paste("Endpoints resulting from QMRA inputs",
                                         "held at the 20th and 80th percentiles",
                                          sep = "\n"),
                           theme = theme(plot.title = element_text(size = 16,
                                                                   hjust = 0.7))) 
                    
plot(patch_both_80)


# Save figure for publication
ggsave("output_QMRA/tornado_80.png", 
        plot = patch_both_80,
        dpi = 300,
        width = 8.5,
        height = 11,
        units = "in")

```



## Make tornado plots, 10th to 90th percentiles
```{r tornado plots for 10th to 90th percentiles, fig.width= 8, fig.height=11}

### Step 1: Pull percentile information from QMRA
inputpercentiles_90 = FUN_inputpercentiles(QMRAdf = allQMRA,
                                          percentile = 0.9)

### Step 2: Calculate a deterministic QMRA for each row of inputpercentiles
detQMRA_90 = FUN_forloop_detQMRA(inputpercentiles = inputpercentiles_90)

### Step 3: Make tornado plots
patch_both_90 = FUN_maketornadopatchwork(detQMRA = detQMRA_90) +
                    plot_annotation(
                           title = paste("Endpoints resulting from QMRA inputs",
                                         "held at the 10th and 90th percentiles",
                                          sep = "\n"), 
                           theme = theme(plot.title = element_text(size = 16,
                                                                   hjust = 0.7))) 
plot(patch_both_90)


# Save figure for publication
ggsave("output_QMRA/tornado_90.png", 
        plot = patch_both_90,
        dpi = 300,
        width = 8.5,
        height = 11,
        units = "in")

```


## Make tornado plots, 1st to 99th percentiles
```{r tornado plots for 1st to 99th percentiles, fig.width= 8, fig.height=11}

### Step 1: Pull percentile information from QMRA
inputpercentiles_99 = FUN_inputpercentiles(QMRAdf = allQMRA,
                                          percentile = 0.99)

### Step 2: Calculate a deterministic QMRA for each row of inputpercentiles
detQMRA_99 = FUN_forloop_detQMRA(inputpercentiles = inputpercentiles_99)

### Step 3: Make tornado plots
patch_both_99 = FUN_maketornadopatchwork(detQMRA = detQMRA_99) +
                    plot_annotation(
                           title = paste("Endpoints resulting from QMRA inputs",
                                         "held at the 1st and 99th percentiles",
                                          sep = "\n"),
                           theme = theme(plot.title = element_text(size = 16,
                                                                   hjust = 0.7))) 
plot(patch_both_99)


# Save figure for publication
ggsave("output_QMRA/tornado_99.png", 
        plot = patch_both_99,
        dpi = 300,
        width = 8.5,
        height = 11,
        units = "in")

```



### Try an example tornado plot from the internet
```{r try tornado from internet}



# # https://rdrr.io/cran/mc2d/man/ggtornado.html
# data(ec)
# x <- evalmcmod(ec$modEC2, nsv=100, nsu=100, seed=666)
# tor <- tornado(x, 7)
# ggtornado(tor)
# data(total)
# ggtornado(tornadounc(total, 10, use="complete.obs"), which=1)


# https://stackoverflow.com/questions/55751978/tornado-both-sided-horizontal-bar-plot-in-r-with-chart-axes-crosses-at-a-given

library(ggplot2)
library(plyr)
library(dplyr)
library(tidyverse)

df <- '
Parameter Lower_Bound Upper_Bound UL_Difference
Parameter01 8074 11181 3108 
Parameter02 8177 11007 2831 
Parameter03 8879 10188 1308 
Parameter04 4358 18697 14339 
Parameter05 9073 10087 1013 
Parameter06 12034 7572 4462 
Parameter07 11357 7933 3423 
Parameter08 9769 9202 567 
Parameter09 8833 10403 1570 
Parameter10 13450 4219 9231 
Parameter11 10691 7915 2776 
Parameter12 10036 8792 1244
' %>% read_table2()

# original value of output
base.value <- 9504

# get order of parameters according to size of intervals
# (I use this to define the ordering of the factors which I then use to define the positions in the plot)
order.parameters <- df %>% arrange(UL_Difference) %>%
  mutate(Parameter=factor(x=Parameter, levels=Parameter)) %>%
  dplyr::select(Parameter) %>% unlist() %>% levels()

# width of columns in plot (value between 0 and 1)
width <- 0.95

# get data frame in shape for ggplot and geom_rect
df.2 <- df %>% 
  # gather columns Lower_Bound and Upper_Bound into a single column using gather
  gather(key='type', value='output.value', Lower_Bound:Upper_Bound) %>%
  # just reordering columns
  dplyr::select(Parameter, type, output.value, UL_Difference) %>%
  # create the columns for geom_rect
  mutate(Parameter=factor(Parameter, levels=order.parameters),
         ymin=pmin(output.value, base.value),
         ymax=pmax(output.value, base.value),
         xmin=as.numeric(Parameter)-width/2,
         xmax=as.numeric(Parameter)+width/2)

# create plot
# (use scale_x_continuous to change labels in y axis to name of parameters)
ggplot() + 
  geom_rect(data = df.2, 
            aes(ymax=ymax, ymin=ymin, xmax=xmax, xmin=xmin, fill=type)) +
  theme_bw() + 
  theme(axis.title.y=element_blank(), legend.position = 'bottom',
        legend.title = element_blank()) + 
  geom_hline(yintercept = base.value) +
  scale_x_continuous(breaks = c(1:length(order.parameters)), 
                     labels = order.parameters) +
  coord_flip()


```


